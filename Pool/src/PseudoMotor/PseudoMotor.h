//=============================================================================
//
// file :        PseudoMotor.h
//
// description : Include for the PseudoMotor class.
//
// project :	Pseudo Motor
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.6  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.5  2007/08/23 10:33:42  tcoutinho
// - basic pseudo counter check
// - some fixes regarding pseudo motors
//
// Revision 1.4  2007/08/20 06:37:32  tcoutinho
// development commit
//
// Revision 1.3  2007/08/17 15:37:43  tcoutinho
// - fix bug: in case pseudo motor controller is in error
//
// Revision 1.2  2007/08/17 13:11:25  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
// Revision 1.1  2007/08/14 07:58:47  tcoutinho
// New initial version of pseudo motor revised
//
//
// copyleft :    European Synchrotron Radiation Facility
//               BP 220, Grenoble 38043
//               FRANCE
//
//=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================
#ifndef _PSEUDOMOTOR_H
#define _PSEUDOMOTOR_H

#include <CtrlFiCa.h>
#include <PoolIndBaseDev.h>
#include <Pool.h>
#include <pool/PseudoMotCtrl.h>

namespace Pool_ns
{
	class Pool;
}

/**
 * @author	$Author$
 * @version	$Revision$
 */

 //	Add your own constants definitions here.
 //-----------------------------------------------

/**
 * @namespace PseudoMotor_ns
 * @author tcoutinho
 * 
 * A namespace dedicated to pseudo motor related classes.
 * Automatically generated by pogo
 * 
 */
namespace PseudoMotor_ns
{

/**
 *  An abstractin level that translates a user meaninfull motor operation into
 *	a real operation on motor(s).
 *	This is done through a pair of translation functions.
 *	Device States Description:
 *  Tango::ON :      All motors are ON
 *  Tango::ALARM :   At least one motor in the group is in ALARM state
 *  Tango::MOVING :  At least one of the motor in the group is MOVING
 *  Tango::FAULT :   At least one motor in the group is in FAULT mode
 */
class PseudoMotor: public Pool_ns::PoolIndBaseDev, public Pool_ns::IConstraintable
//class PseudoMotor: public Tango::Device_3Impl
{
public :
	//	Add your own data members here
	//-----------------------------------------

	
	//	Here is the Start of the automatic code generation part
	//-------------------------------------------------------------	
/**
 *	@name attributes
 *	Attributs member data.
 */
//@{
		Tango::DevDouble	*attr_Position_read;
		Tango::DevDouble	attr_Position_write;
//@}

/**
 *	@name Device properties
 *	Device properties member data.
 */
//@{
/**
 *	The pseudo motor identifier
 */
	Tango::DevLong	pseudo_motor_id;
/**
 *	List of motors used by the pseudo motor
 */
	vector<string>	motor_list;
/**
 *	The motor group being used by this pseudo motor
 */
	string	motor_group;
/**
 *	The role of this pseudo motor in the pseudo motor controller
 */
	string	role;
//@}

/**@name Constructors
 * Miscellaneous constructors */
//@{
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
	PseudoMotor(Tango::DeviceClass *cl,string &s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
	PseudoMotor(Tango::DeviceClass *cl,const char *s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device name
 *	@param d	Device description.
 */
	PseudoMotor(Tango::DeviceClass *cl,const char *s,const char *d);
//@}

/**@name Destructor
 * Only one desctructor is defined for this class */
//@{
/**
 * The object desctructor.
 */	
	~PseudoMotor() {delete_device();};
/**
 *	will be called at device destruction or at init command.
 */
	void delete_device();
//@}

	
/**@name Miscellaneous methods */
//@{
/**
 *	Initialize the device
 */
	virtual void init_device();
/**
 *	Always executed method befor execution command method.
 */
	virtual void always_executed_hook();

//@}

/**
 * @name PseudoMotor methods prototypes
 */

//@{
/**
 *	Hardware acquisition for attributes.
 */
	virtual void read_attr_hardware(vector<long> &attr_list);
/**
 *	Extract real attribute values for Position acquisition result.
 */
	virtual void read_Position(Tango::Attribute &attr);
/**
 *	Write Position attribute values to hardware.
 */
	virtual void write_Position(Tango::WAttribute &attr);
/**
 *	Read/Write allowed for Position attribute.
 */
	virtual bool is_Position_allowed(Tango::AttReqType type);
/**
 *	Execution allowed for Abort command.
 */
	virtual bool is_Abort_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for MoveRelative command.
 */
	virtual bool is_MoveRelative_allowed(const CORBA::Any &any);
/**
 * This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *	@return	State Code
 *	@exception DevFailed
 */
	virtual Tango::DevState	dev_state();
/**
 * This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *	@return	Status description
 *	@exception DevFailed
 */
	virtual Tango::ConstDevString	dev_status();
/**
 * Abort movement of all motors that are moving when the command is executed
 *	@exception DevFailed
 */
	void	abort();
/**
 * move relative command
 *	@param	argin	amount to move
 *	@exception DevFailed
 */
	void	move_relative(Tango::DevDouble);

/**
 *	Read the device properties from database
 */
	 void get_device_property();
//@}

	//	Here is the end of the automatic code generation part
	//-------------------------------------------------------------	

	typedef struct MotGroupMov
	{
		Tango::DeviceProxy		*mg_proxy;
		Tango::DevState			mg_state;
	};
	MotGroupMov					mov_mg;
	
	Tango::DevDouble get_last_position_set();
	
	MotGroupMov& get_motor_group_info() 			{ return mov_mg; }
	virtual long get_id() 							{ return pseudo_motor_id; }
	virtual void base_abort(bool);
	void set_group_mov(bool val)					{ grp_mov = val; }
	void set_pseudo_motor_mov(bool val)				{ pm_mov = val; }
	PseudoMotorController *get_pm_ctrl() 
	{ return static_cast<PseudoMotorController *>(my_ctrl); }
	Pool_ns::PseudoMotCtrlFiCa *get_pm_fica_ptr()
	{ return static_cast<Pool_ns::PseudoMotCtrlFiCa*>(fica_ptr); }

	double calc_pseudo(string &,double);
	
	void pool_elem_changed(Pool_ns::PoolElemEventList &,
						   Pool_ns::PoolElementEvent &);

	virtual void init_pool_element(Pool_ns::PoolElement *);
	
	void set_siblings(vector<PseudoMotor*> &s)		{ siblings = s; }
	void sibling_died(long role);
	
protected :	
	//	Add your own data members here
	//-----------------------------------------
	
 	bool 					last_set_pos_valid;	///< flag indicating if the pseudo motor position is to be considered from the last tango Set Position 
	bool					grp_mov;			///< set to true if the current movement is originated by the motor group
	bool					pm_mov;				///< set to true if the current movement is originated by a pseudo motor in the pseudo motor system
	bool					pm_mov_src;			///< set to true if this pseudo motor is the one that originated the current movement
	
	vector<PseudoMotor*>	siblings;
	
	virtual Pool_ns::PoolElement &get_pool_obj();
	virtual void inform_ghost(Tango::DevState,Tango::DevState) {}
	
	void update_state(Tango::DevState *mg_state = NULL);
	long get_motor_role_from_name(string &);
	
	void set_pseudo_motor_mov_src(bool val) 	{pm_mov_src = val;}
	
	void inform_siblings_pseudo_motor_mov(bool );
};

}	// namespace_ns

#endif	// _PSEUDOMOTOR_H
