//=============================================================================
//
// file :        Motor.h
//
// description : Include for the Motor class.
//
// project :	Motor generic client class
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.37  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.36  2007/08/17 13:07:29  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
// Revision 1.35  2007/08/07 09:51:06  tcoutinho
// Fix bug 24: Motor.state() and ghostGroup.state() return different states
//
// Revision 1.34  2007/05/25 12:48:10  tcoutinho
// fix the same dead locks found on motor system to the acquisition system since release labeled for Josep Ribas
//
// Revision 1.33  2007/05/22 13:43:09  tcoutinho
// - added new method
//
// Revision 1.32  2007/01/16 14:26:02  etaurel
// - First release with the PoolBaseDev base class
//
// Revision 1.31  2007/01/04 11:54:14  etaurel
// - Added the CounterTimer controller
//
// Revision 1.30  2006/12/28 15:34:13  etaurel
// - Fire change event on limit_switches attributes
// - Manage position limit on dial position
// - Throw events even in Simulation mode
//
// Revision 1.29  2006/12/18 11:35:29  etaurel
// - Features are only boolean values invisible from the external world
// - ExtraFeature becomes ExtraAttribute with data type of the old features
//
// Revision 1.28  2006/11/23 10:48:11  etaurel
// - Change in write_position to check psm (in case of)
//
// Revision 1.27  2006/11/20 14:35:00  etaurel
// - Add ghost group and event on group position
//
// Revision 1.26  2006/11/03 15:48:14  etaurel
// - Miscellaneous changes that I don't remember
//
// Revision 1.25  2006/10/25 10:05:02  etaurel
// - Complete implementation of the ReloadControllerCode command
// - Handle end of movment when reading position in polling mode
//
// Revision 1.24  2006/10/20 15:42:10  etaurel
// - First release with GetControllerInfo command supported and with
// controller properties
//
// Revision 1.23  2006/10/16 16:11:26  tcoutinho
// fix to avoid compilation warning
//
// Revision 1.22  2006/10/06 10:43:19  etaurel
// - Rounding motor feature is now supported
//
// Revision 1.21  2006/10/05 14:54:09  etaurel
// - Test suite of motor controller features is now working
//
// Revision 1.20  2006/10/05 08:00:16  etaurel
// - Controller now supports dynamic features
//
// Revision 1.19  2006/10/02 13:19:25  etaurel
// - Motor extra feature test suite now running OK
//
// Revision 1.18  2006/10/02 09:19:46  etaurel
// - Motor controller now supports extra features (both CPP and Python)
//
// Revision 1.17  2006/09/20 13:11:33  etaurel
// - For the user point of view, the controller does not have ID any more.
// We are now using the controller instance name (uniq) to give them a name
//
// Revision 1.16  2006/09/15 07:50:53  etaurel
// - Abort command always possible
// - Remove the Reset command
//
// Revision 1.15  2006/08/17 09:56:14  etaurel
// - Add limit_switches attributes
//
// Revision 1.14  2006/07/07 12:39:55  etaurel
// - Commit after implementing the group multi motor read
//
// Revision 1.13  2006/07/03 08:40:21  etaurel
// - Add DialPosition and Offset attributes
//
// Revision 1.12  2006/06/28 15:56:11  etaurel
// - Commit after first series of tests
//
// Revision 1.11  2006/06/21 14:48:34  etaurel
// - Don't remember the changes I did..
//
// Revision 1.10  2006/06/19 12:34:36  etaurel
// - Changes in the Motr state machine and in the delete_device() method for a better pool shut down
//
// Revision 1.9  2006/06/15 15:37:01  etaurel
// - many changes after due to first test suite only on controller related stuff!!!
//
// Revision 1.8  2006/06/12 10:28:26  etaurel
// - Many changes dur to bug fixes found when writing test units...
//
// Revision 1.7  2006/05/26 09:12:24  etaurel
// - Add some exception checking between the thread used to move motor and the
// write_Position method
//
// Revision 1.6  2006/05/24 14:12:07  etaurel
// - Several changes...
//
// Revision 1.5  2006/04/27 07:28:44  etaurel
// - Many changes after the travel to Boston
//
// Revision 1.4  2006/03/27 12:53:49  etaurel
// - Commit before adding MotorGroup class
//
// Revision 1.3  2006/03/21 14:31:55  etaurel
// - Many changes.....
//
// Revision 1.2  2006/03/20 08:26:13  etaurel
// - Commit changes before changing the Motor interface
//
// Revision 1.1.1.1  2006/03/10 13:40:58  etaurel
// Initial import
//
//
// copyleft :     CELLS/ALBA
//				  Edifici Ciències Nord. Mòdul C-3 central.
//  			  Campus Universitari de Bellaterra. Universitat Autònoma de Barcelona
//  			  08193 Bellaterra, Barcelona
//  			  Spain
//
//=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================
#ifndef _MOTOR_H
#define _MOTOR_H

#include <PoolIndBaseDev.h>
#include <pool/MotCtrl.h>

namespace Pool_ns
{
	class Pool;
}

//using namespace Tango;

/**
 * @author	$Author$
 * @version	$Revision$
 */

 //	Add your own constants definitions here.
 //-----------------------------------------------

namespace Motor_ns
{

/**
 * Class Description:
 * 
 */

/*
 *	Device States Description:
*  Tango::ON :       *
*  Tango::FAULT :    *
*  Tango::MOVING :   The motor is moving
*  Tango::ALARM :    The motor has reached a limit (upper or lower)
*  Tango::UNKNOWN :  Impossible to communicate with the controller
 */


class Motor: public Pool_ns::PoolIndBaseDev
{
public :
	//	Add your own data members here
	//-----------------------------------------


	//	Here is the Start of the automatic code generation part
	//-------------------------------------------------------------	
/**
 *	@name attributes
 *	Attributs member data.
 */
//@{
		Tango::DevDouble	*attr_Position_read;
		Tango::DevDouble	attr_Position_write;
		Tango::DevBoolean	*attr_SimulationMode_read;
		Tango::DevDouble	*attr_Acceleration_read;
		Tango::DevDouble	attr_Acceleration_write;
		Tango::DevDouble	*attr_Deceleration_read;
		Tango::DevDouble	attr_Deceleration_write;
		Tango::DevDouble	*attr_Base_rate_read;
		Tango::DevDouble	attr_Base_rate_write;
		Tango::DevDouble	*attr_Velocity_read;
		Tango::DevDouble	attr_Velocity_write;
		Tango::DevDouble	*attr_Offset_read;
		Tango::DevDouble	attr_Offset_write;
		Tango::DevDouble	*attr_DialPosition_read;
		Tango::DevDouble	*attr_Step_per_unit_read;
		Tango::DevDouble	attr_Step_per_unit_write;
		Tango::DevLong	*attr_Backlash_read;
		Tango::DevLong	attr_Backlash_write;
		Tango::DevBoolean	*attr_Limit_switches_read;
//@}

/**
 *	@name Device properties
 *	Device properties member data.
 */
//@{
/**
 *	The motor identificator
 */
	Tango::DevLong	motor_id;
/**
 *	
 */
	Tango::DevDouble	_Acceleration;
/**
 *	
 */
	Tango::DevDouble	_Velocity;
/**
 *	
 */
	Tango::DevDouble	_Base_rate;
/**
 *	
 */
	Tango::DevDouble	_Deceleration;
/**
 *	Number of mS to sleep before the last read during a motor movement
 */
	Tango::DevLong	sleep_bef_last_read;
//@}

/**@name Constructors
 * Miscellaneous constructors */
//@{
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
	Motor(Tango::DeviceClass *cl,string &s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
	Motor(Tango::DeviceClass *cl,const char *s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device name
 *	@param d	Device description.
 */
	Motor(Tango::DeviceClass *cl,const char *s,const char *d);
//@}

/**@name Destructor
 * Only one desctructor is defined for this class */
//@{
/**
 * The object desctructor.
 */	
	~Motor() {delete_device();};
/**
 *	will be called at device destruction or at init command.
 */
	void delete_device();
//@}

	
/**@name Miscellaneous methods */
//@{
/**
 *	Initialize the device
 */
	virtual void init_device();
/**
 *	Always executed method befor execution command method.
 */
	virtual void always_executed_hook();

//@}

/**
 * @name Motor methods prototypes
 */

//@{
/**
 *	Hardware acquisition for attributes.
 */
	virtual void read_attr_hardware(vector<long> &attr_list);
/**
 *	Extract real attribute values for Position acquisition result.
 */
	virtual void read_Position(Tango::Attribute &attr);
/**
 *	Write Position attribute values to hardware.
 */
	virtual void write_Position(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for SimulationMode acquisition result.
 */
	virtual void read_SimulationMode(Tango::Attribute &attr);
/**
 *	Extract real attribute values for Acceleration acquisition result.
 */
	virtual void read_Acceleration(Tango::Attribute &attr);
/**
 *	Write Acceleration attribute values to hardware.
 */
	virtual void write_Acceleration(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Deceleration acquisition result.
 */
	virtual void read_Deceleration(Tango::Attribute &attr);
/**
 *	Write Deceleration attribute values to hardware.
 */
	virtual void write_Deceleration(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Base_rate acquisition result.
 */
	virtual void read_Base_rate(Tango::Attribute &attr);
/**
 *	Write Base_rate attribute values to hardware.
 */
	virtual void write_Base_rate(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Velocity acquisition result.
 */
	virtual void read_Velocity(Tango::Attribute &attr);
/**
 *	Write Velocity attribute values to hardware.
 */
	virtual void write_Velocity(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Offset acquisition result.
 */
	virtual void read_Offset(Tango::Attribute &attr);
/**
 *	Write Offset attribute values to hardware.
 */
	virtual void write_Offset(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for DialPosition acquisition result.
 */
	virtual void read_DialPosition(Tango::Attribute &attr);
/**
 *	Extract real attribute values for Step_per_unit acquisition result.
 */
	virtual void read_Step_per_unit(Tango::Attribute &attr);
/**
 *	Write Step_per_unit attribute values to hardware.
 */
	virtual void write_Step_per_unit(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Backlash acquisition result.
 */
	virtual void read_Backlash(Tango::Attribute &attr);
/**
 *	Write Backlash attribute values to hardware.
 */
	virtual void write_Backlash(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Limit_switches acquisition result.
 */
	virtual void read_Limit_switches(Tango::Attribute &attr);
/**
 *	Read/Write allowed for Position attribute.
 */
	virtual bool is_Position_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for SimulationMode attribute.
 */
	virtual bool is_SimulationMode_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Acceleration attribute.
 */
	virtual bool is_Acceleration_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Deceleration attribute.
 */
	virtual bool is_Deceleration_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Base_rate attribute.
 */
	virtual bool is_Base_rate_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Velocity attribute.
 */
	virtual bool is_Velocity_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Offset attribute.
 */
	virtual bool is_Offset_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for DialPosition attribute.
 */
	virtual bool is_DialPosition_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Step_per_unit attribute.
 */
	virtual bool is_Step_per_unit_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Backlash attribute.
 */
	virtual bool is_Backlash_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Limit_switches attribute.
 */
	virtual bool is_Limit_switches_allowed(Tango::AttReqType type);
/**
 *	Execution allowed for Abort command.
 */
	virtual bool is_Abort_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for DefinePosition command.
 */
	virtual bool is_DefinePosition_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for SaveConfig command.
 */
	virtual bool is_SaveConfig_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for MoveRelative command.
 */
	virtual bool is_MoveRelative_allowed(const CORBA::Any &any);
/**
 * This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *	@return	Status description
 *	@exception DevFailed
 */
	virtual Tango::ConstDevString	dev_status();
/**
 * Abort a running movement
 *	@exception DevFailed
 */
	void	abort();
/**
 * Define the motor position
 *	@param	argin	New position
 *	@exception DevFailed
 */
	void	define_position(Tango::DevDouble);
/**
 * Write motor parameters in database
 *	@exception DevFailed
 */
	void	save_config();
/**
 * Move relative command
 *	@param	argin	amount to move
 *	@exception DevFailed
 */
	void	move_relative(Tango::DevDouble);

/**
 *	Read the device properties from database
 */
	 void get_device_property();
//@}

	//	Here is the end of the automatic code generation part
	//-------------------------------------------------------------	



protected :	
	//	Add your own data members here
	//-----------------------------------------
	
	long				motor_idx;
	string				full_motor_name;
	
	double				depl_per_step;
	double				backlash_depl;
	
	bool				init_from_db_done;
	Tango::DevBoolean	switches[3];
	double				dial_pos;
	double				back_pos;
	double				writed_pos;
	double				attr_Position_write_simu;
	bool				grp_mov;
	
	Tango::TangoMonitor	*pos_mon;
	long				old_switches;

	typedef struct Simu_data
	{	
		double			simu_pos;
		double			simu_acc;
		double			simu_dec;
		double			simu_vel;
		double			simu_base;
		double			simu_offset;
		double			simu_step;
		long			simu_backlash;
		Motor			*mot;
		
		Simu_data(Motor *);
		~Simu_data();
	};
	
	Simu_data			*save_atts;
	double read_position_from_ctrl();
	void store_switches(long &);

	// Warning: the following method should only be executed
	// when the running thread has a lock on the Pool
	Pool_ns::PoolElement &get_pool_obj();

	void inform_ghost(Tango::DevState,Tango::DevState);
	
public:
	virtual long get_id() 						{ return motor_id; }
	virtual void base_abort(bool);
	
	void init_from_db();
	
	void save_att_values() {save_atts = new Simu_data(this);}
	void restore_att_values() {if (save_atts!=NULL){delete save_atts;save_atts=NULL;}}
	
	void set_group_movement(bool val) {grp_mov = val;}
	double get_dial_pos() {return dial_pos;}
	double get_back_pos() {return back_pos;}
	double get_writed_pos() {return writed_pos;}
	double get_offset() {return attr_Offset_write;}
	void set_motor_state_from_group(MotorController::MotorState &);
	
	virtual void init_pool_element(Pool_ns::PoolElement *);
	
	bool				th_failed;
	Tango::DevErrorList	th_except;
	
	time_t				sbr_sec;
	long				sbr_nsec;
	
	double				mot_NaN;
	long				sf_index;
};

}	// namespace_ns

#endif	// _MOTOR_H
