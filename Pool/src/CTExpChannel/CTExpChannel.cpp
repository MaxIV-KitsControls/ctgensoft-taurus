static const char *RcsId = "$Header$";
//+=============================================================================
//
// file :         CTExpChannel.cpp
//
// description :  C++ source for the CTExpChannel and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                CTExpChannel are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.18  2007/09/07 15:00:07  tcoutinho
// safety commit
//
// Revision 1.17  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.16  2007/08/17 13:07:29  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
// Revision 1.15  2007/07/26 07:05:42  tcoutinho
// fix bug 10 : Change all tango commands from Stop to Abort
//
// Revision 1.14  2007/05/30 14:37:24  etaurel
// - In inform_ghost() method, dont propagate event if the old_state is
// MOVING. It will be done by the "action" thread
//
// Revision 1.13  2007/05/25 12:48:10  tcoutinho
// fix the same dead locks found on motor system to the acquisition system since release labeled for Josep Ribas
//
// Revision 1.12  2007/05/22 13:43:09  tcoutinho
// - added new method
//
// Revision 1.11  2007/05/15 07:17:45  etaurel
// - Re-insert device in ghost group in case of Init command
//
// Revision 1.10  2007/02/22 11:52:55  tcoutinho
// - added support for ghost measurement group
//
// Revision 1.9  2007/02/16 10:02:42  tcoutinho
// - new method to set the state coming from a measurement group (maybe in the future move it to the super class)
//
// Revision 1.8  2007/02/08 16:18:13  tcoutinho
// - controller safety on PoolGroupBaseDev
//
// Revision 1.7  2007/02/08 10:49:57  etaurel
// - Some small changes after the merge
//
// Revision 1.6  2007/02/08 07:55:00  etaurel
// - Changes after compilation -Wall. Some small changes
//
// Revision 1.5  2007/01/30 16:41:58  etaurel
// - Fix bug in PoolBaseDev data member initialization
//
// Revision 1.4  2007/01/30 15:56:28  etaurel
// - Fix some memory leaks
// - Value is now a Double attribute
//
// Revision 1.3  2007/01/16 16:50:03  etaurel
// - It's now possible to write the Value attribute
//
// Revision 1.2  2007/01/16 14:23:18  etaurel
// - First release with Counter Timer
//
// Revision 1.1  2007/01/05 15:03:14  etaurel
// - First implementation of the Counter Timer class
//
//
// copyleft :   CELLS/ALBA
//		Edifici Ciences Nord
//		Campus Universitari de Bellaterra
//		Universitat Autonoma de Barcelona
//		08193 Bellaterra, Barcelona, SPAIN
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//  Start   |  start()
//  Abort   |  abort()
//
//===================================================================

#include <CtrlFiCa.h>
#include <tango.h>
#include <Pool.h>
#include <CTExpChannel.h>
#include <CTExpChannelClass.h>
#include <CTExpChannelUtil.h>
#include <CTPoolThread.h>
#include <pool/CoTiCtrl.h>



namespace CTExpChannel_ns
{

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::CTExpChannel(string &s)
// 
// description : 	constructor for simulated CTExpChannel
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
CTExpChannel::CTExpChannel(Tango::DeviceClass *cl,string &s)
//:Tango::Device_3Impl(cl,s.c_str())
:Pool_ns::PoolIndBaseDev(cl,s.c_str())
{
	init_cmd = false;
	init_device();
}

CTExpChannel::CTExpChannel(Tango::DeviceClass *cl,const char *s)
//:Tango::Device_3Impl(cl,s.c_str())
:Pool_ns::PoolIndBaseDev(cl,s)
{
	init_cmd = false;
	init_device();
}

CTExpChannel::CTExpChannel(Tango::DeviceClass *cl,const char *s,const char *d)
//:Tango::Device_3Impl(cl,s.c_str())
:Pool_ns::PoolIndBaseDev(cl,s,d)
{
	init_cmd = false;
	init_device();
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void CTExpChannel::delete_device()
{
	//	Delete device's allocated object
	
//
// To know that we are executing this code due to a pool shutdown and not due to a
// "Init" command, we are using the polling thread ptr which is cleared in the DS
// shutdown sequence before the device destruction
//
	bool sd = false;

	Tango::Util *tg = Tango::Util::instance();
	if (tg->get_polling_thread_object() != NULL)
	{
		if (get_state() == Tango::MOVING)
		{
			TangoSys_OMemStream o;
			o << "Init command on counter timer device is not allowed while a counter timer is counting" << ends;

			Tango::Except::throw_exception((const char *)"CTExp_InitNotAllowed",o.str(),
				  	(const char *)"CTExpChannel::delete_device");
		}
	}
	else
	{
		sd = true;
	}

//
// If we are not in a shutdown sequence:
// Lock the ghost group in order the polling thread not to
// start requesting for motor state while we are deleting it and
// inform ghost group that there is one channel less
//
// If we are called due to a Init command on the DServer admin,
// the measurement_group class is already deleted and the ghost group
// as well
//

	if (sd == false)
	{
		bool measurementgroup_class_deleted = false;
		MeasurementGroup_ns::MeasurementGroup *ghost_ptr;
		
		try
		{
			ghost_ptr = pool_dev->get_ghost_measurement_group_ptr();
		}
		catch (Tango::DevFailed &e)
		{
			measurementgroup_class_deleted = true;
		}
		
		if (measurementgroup_class_deleted == false)
		{
			Tango::AutoTangoMonitor atm(ghost_ptr);
			ghost_ptr->remove_channel_from_ghost_group(channel_id);
		}
	}

	if (pos_mon != NULL)
		delete pos_mon;
	
//
// Delete the device from its controller and from the pool
//

	delete_from_pool();
	delete_utils();
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void CTExpChannel::init_device()
{
	INFO_STREAM << "CTExpChannel::CTExpChannel() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();
	
	set_state(Tango::ON);
	string &_status = get_status();
	_status = StatusNotSet;
	
//
// If we are called due to a init command, re-init variables in the
// base class
//

	if (init_cmd == true)
		base_init();

//
// Init some variables
//
	
	attr_SimulationMode_read = &simu;
	attr_Value_read = &read_value;
	
	pos_mon = new Tango::TangoMonitor("PoolCountingThread");
	
//
// We will push change event on State and Value attributes
//

	Tango::Attribute &state_att = dev_attr->get_attr_by_name("state");
	state_att.set_change_event(true,false);
	
	Tango::Attribute &val_att = dev_attr->get_attr_by_name("Value");
	val_att.set_change_event(true);
		
//
// Build the PoolBaseUtils class depending on the
// controller type
//

	set_utils(new CTExpChannelUtil(pool_dev));
	
//
// Inform Pool of our birth
//

	Pool_ns::CTExpChannelPool ctp;
	init_pool_element(&ctp);
	
	{
		Tango::AutoTangoMonitor atm(pool_dev);	
		pool_dev->add_counter_timer(ctp);
	}

//
// Inform controller of our birth
//

	a_new_child(ctp.ctrl_id);
	
//
// If we are called due to a init command, update our info in the
// ghost group
//
		
	if (init_cmd == true)
	{
		MeasurementGroup_ns::MeasurementGroup *ghost_ptr = pool_dev->get_ghost_measurement_group_ptr();
		{
			Tango::AutoTangoMonitor atm(ghost_ptr);
			ghost_ptr->add_ct_to_ghost_group(channel_id);
		}
		init_cmd = false;
	}
}

void CTExpChannel::init_pool_element(Pool_ns::PoolElement *pe)
{
	PoolIndBaseDev::init_pool_element(pe);
	
	Pool_ns::CTExpChannelPool *ctp =
		static_cast<Pool_ns::CTExpChannelPool *>(pe);
	
	ctp->ct_channel = this;
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void CTExpChannel::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Channel_id"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	CTExpChannelClass	*ds_class =
		(static_cast<CTExpChannelClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize Channel_id from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  channel_id;
	//	Try to initialize Channel_id from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  channel_id;
	//	And try to extract Channel_id value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  channel_id;



	//	End of Automatic code generation
	//------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------

void CTExpChannel::always_executed_hook()
{

	base_always_executed_hook(false);

}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::inform_ghost
// 
// description : 	inform ghost group of a change in the state
//
//-----------------------------------------------------------------------------
void CTExpChannel::inform_ghost(Tango::DevState old_state,Tango::DevState new_state)
{

	if (old_state != Tango::MOVING)
	{	
		if(old_state != new_state && 
	       new_state != Tango::ON &&
	       new_state != Tango::MOVING)
		{
			MeasurementGroup_ns::MeasurementGroup *ghost = pool_dev->get_ghost_measurement_group_ptr();
			long idx = ghost->get_ind_elt_idx_from_id(channel_id);
			Tango::AutoTangoMonitor synch(ghost);
			ghost->update_state_from_ctrls(idx,new_state);
		}	
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void CTExpChannel::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "CTExpChannel::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::write_Value
// 
// description : 	Write Value attribute values to hardware.
//
//-----------------------------------------------------------------------------
void CTExpChannel::write_Value(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "CTExpChannel::write_Value(Tango::WAttribute &attr) entering... "<< endl;
	
	double old_value = attr_Value_write;	
	attr.get_write_value(attr_Value_write);
	DEBUG_STREAM << "Motor: new value = " << attr_Value_write << endl;
/*
	if (attr_Value_write < 0.0)
	{
		attr_Value_write = old_value;
		Tango::Except::throw_exception((const char *)"CTExpChannel_BadArgument",
					  (const char *)"Value cannot be negative",
					  (const char *)"CTExpChannel::write_Value");
	}
*/		
	if (simu == false)
	{
		Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
		CoTiController *typed_ctrl = static_cast<CoTiController *>(my_ctrl);
		
		bool res;
		try
		{
			typed_ctrl->PreLoadAll();
			res = typed_ctrl->PreLoadOne(ct_idx,attr_Value_write);
		}
		SAFE_CATCH(fica_ptr->get_name(),"write_Value");
		
		if (res == false)
		{
			attr_Value_write = old_value;
			Tango::Except::throw_exception((const char *)"CTExpChannel_BadArgument",
					  (const char *)"Value refused by controller. Its PreLoadOne() method returns false",
					  (const char *)"CTExpChannel::write_Value");
		}

		try
		{			
			typed_ctrl->LoadOne(ct_idx,attr_Value_write);
			typed_ctrl->LoadAll();
		}
		SAFE_CATCH(fica_ptr->get_name(),"write_Value");
	}

}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::read_SimulationMode
// 
// description : 	Extract real attribute values for SimulationMode acquisition result.
//
//-----------------------------------------------------------------------------
void CTExpChannel::read_SimulationMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "CTExpChannel::read_SimulationMode(Tango::Attribute &attr) entering... "<< endl;
	
	attr.set_value(attr_SimulationMode_read);
}


//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::read_Value
// 
// description : 	Extract real attribute values for Value acquisition result.
//
//-----------------------------------------------------------------------------
void CTExpChannel::read_Value(Tango::Attribute &attr)
{
	DEBUG_STREAM << "CTExpChannel::read_Value(Tango::Attribute &attr) entering... "<< endl;

	if (simu == false)
	{
		Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());

		double ctr_value;
		try
		{
			CoTiController *typed_ctrl = static_cast<CoTiController *>(my_ctrl);
			
			typed_ctrl->PreReadAll();
			typed_ctrl->PreReadOne(ct_idx);
			typed_ctrl->ReadAll();
			ctr_value = typed_ctrl->ReadOne(ct_idx);
		}
		SAFE_CATCH(fica_ptr->get_name(),"read_Value");
		
		if (ctr_value == LONG_MAX)
		{
			Tango::Except::throw_exception((const char *)"CTExpChannel_BadController",
				  (const char *)"The CounterTimer controller class has not re-defined method to read value (readOne(...))",
				  (const char *)"CTExpChannel::read_Value");
		}
		else
			read_value = ctr_value;
	}
	else
	{
		read_value = 0.0;
	}
	
	attr.set_value(attr_Value_read);

	Tango::DevState ct_sta = get_state();

//
// Set the attribute quality factor
//
	
	if (ct_sta == Tango::MOVING)
		attr.set_quality(Tango::ATTR_CHANGING);
}


//+------------------------------------------------------------------
/**
 *	method:	CTExpChannel::start
 *
 *	description:	method to execute "Start"
 *	Start counting
 *
 *
 */
//+------------------------------------------------------------------
void CTExpChannel::start()
{
	DEBUG_STREAM << "CTExpChannel::start(): entering... !" << endl;

	//	Add your own code to control device here

	//
	// Start the thread doing the job
	//	
					
		if (simu == false)
		{
			Pool_ns::AquisitionInfo aq_info;
			
			aq_info.master_id = channel_id;
			aq_info.master_value = 0.0;
			aq_info.mode = Pool_ns::aqNone;
			aq_info.master_idx_in_cts = 0;
			aq_info.master_idx_in_grp = 0;
			aq_info.ct_ids.push_back(channel_id);
	
			th_failed = false;
			abort_cmd_executed = false;
				
	//
	// Create the counting thread, but start it only while the pos_mon
	// lock is taken. Otherwise, a dead-lock can happen, if the thread
	// start excuting its code just after the start and before this code
	// enter into the wait. The thread will send the signal but while
	// this thread is not yet waiting for it and afterwards, we will have
	// a dead-lock...
	//
	
			Pool_ns::CTPoolThread *ct_pool_th = new Pool_ns::CTPoolThread(aq_info,pool_dev,pos_mon);
	
			{
				omni_mutex_lock lo(*pos_mon);
				ct_pool_th->start();
				pos_mon->wait();
			}
			
			if (th_failed == true)
			{
				Tango::DevFailed ex(th_except);
				throw ex;
			}
		}
		else
		{
			
	//
	// Fire events on state and value like the couting thread is doing
	//
	
			Tango::Attribute &state_att = dev_attr->get_attr_by_name("state");
			set_state(Tango::MOVING);
			state_att.fire_change_event();
			
			set_state(Tango::ON);
			state_att.fire_change_event();
	
			Tango::Attribute &val_att = dev_attr->get_attr_by_name("Value");
			read_Value(val_att);
			val_att.set_change_event(true,false);
			val_att.fire_change_event();
			val_att.set_change_event(true);
		}		

}

//+------------------------------------------------------------------
/**
 *	method:	CTExpChannel::abort
 *
 *	description:	method to execute "Abort"
 *	Stop counting
 *
 *
 */
//+------------------------------------------------------------------
void CTExpChannel::abort()
{
	DEBUG_STREAM << "CTExpChannel::stop(): entering... !" << endl;

	//	Add your own code to control device here
	base_abort(true);
}

void CTExpChannel::base_abort(bool send_evt)
{
//
// Do nothing if the counter is not counting
//

	if (get_state() != Tango::MOVING)
		return;
		
//
// Send abort command to the controller
//

	if (simu == false)
	{
		Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
		CoTiController *typed_ctrl = static_cast<CoTiController *>(my_ctrl);
		
		try
		{
			typed_ctrl->AbortOne(ct_idx);
		}
		SAFE_CATCH(fica_ptr->get_name(),"abort");

		if(send_evt)
		{
			abort_cmd_executed = true;		

			always_executed_hook();
			
			Tango::MultiAttribute *dev_attrs = get_device_attr();
			Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
			state_att.fire_change_event();
			//
			// Value attribute quality factor is VALID
			//
			Tango::WAttribute &val_att = dev_attrs->get_w_attr_by_name("Value");
			val_att.set_quality(Tango::ATTR_VALID);
		}
	}
	else
	{
		Tango::Except::throw_exception((const char *)"CTExpChannel_SimuMode",
									   (const char *)"Command not allowed when counter is in simulation mode",
									   (const char *)"CTExpChannel::abort");
	}
}
		
//+------------------------------------------------------------------
/**
 *	method:	CTExpChannel::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status description
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString CTExpChannel::dev_status()
{
	Tango::ConstDevString	argout = DeviceImpl::dev_status();
	DEBUG_STREAM << "CTExpChannel::dev_status(): entering... !" << endl;

	//	Add your own code to control device here

	base_dev_status(argout);
	
	argout = tmp_status.c_str();
	return argout;
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::set_state_from_group
// 
// description : 	Set the device state from the info gathered by a state
//					command on a group from which this motor is one of the element
//
//-----------------------------------------------------------------------------

void CTExpChannel::set_state_from_group(Controller::CtrlState &ci)
{
	set_state((Tango::DevState)ci.state);

	if ((Tango::DevState)ci.state == Tango::FAULT)
		ctrl_error_str = ci.status;
}

//+----------------------------------------------------------------------------
//
// method : 		CTExpChannel::get_pool_obj
// 
// description : 	gets Pool counter/timer object for this counter/timer.
//                  Warning: the following method should only be executed
//                  when the running thread has a lock on the Pool
//
// \return the pool counter/timer object
//-----------------------------------------------------------------------------

Pool_ns::PoolElement &CTExpChannel::get_pool_obj()
{ 
	return pool_dev->get_exp_channel_from_id(channel_id);
}

}	//	namespace
