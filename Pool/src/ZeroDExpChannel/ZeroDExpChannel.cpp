static const char *RcsId = "$Header$";
//+=============================================================================
//
// file :         ZeroDExpChannel.cpp
//
// description :  C++ source for the ZeroDExpChannel and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                ZeroDExpChannel are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.14  2007/09/07 16:23:46  tcoutinho
// safety commit
//
// Revision 1.13  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.12  2007/08/17 13:07:30  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
// Revision 1.11  2007/07/26 07:05:42  tcoutinho
// fix bug 10 : Change all tango commands from Stop to Abort
//
// Revision 1.10  2007/05/30 14:51:19  etaurel
// - Add init of the i_am_dead data in the shared data area
// - Change the inform_ghost() method to propagate event only if the old
// state value is not MOVING
//
// Revision 1.9  2007/05/25 13:34:18  tcoutinho
// - fixes to state event propagation to the ghost group
//
// Revision 1.8  2007/05/22 13:43:09  tcoutinho
// - added new method
//
// Revision 1.7  2007/05/15 07:18:58  etaurel
// - Re-insert device in ghost group in case of Init command
//
// Revision 1.6  2007/05/11 08:43:56  tcoutinho
// - fixed bugs
//
// Revision 1.5  2007/05/10 09:32:34  etaurel
// - Small changes for better 64 bits portability
//
// Revision 1.4  2007/02/22 12:05:45  tcoutinho
// - added support for ghost measurement group
//
// Revision 1.3  2007/02/08 07:56:49  etaurel
// - Changes after compilation -Wall. Added the CumulatedValue attribute and
// everything to implement it (thread....)
//
// Revision 1.2  2007/01/30 16:42:21  etaurel
// - Fix bug in PoolBaseDev data member initialization
//
// Revision 1.1  2007/01/26 08:35:02  etaurel
// - We now have a first release of ZeroDController
//
//
// copyleft :   CELLS/ALBA
//		Edifici Ciences Nord
//		Campus Universitari de Bellaterra
//		Universitat Autonoma de Barcelona
//		08193 Bellaterra, Barcelona, SPAIN
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//  Start   |  start()
//  Abort   |  abort()
//
//===================================================================


#include <CtrlFiCa.h>
#include <tango.h>
#include <Pool.h>
#include <ZeroDExpChannel.h>
#include <ZeroDExpChannelClass.h>
#include <ZeroDExpChannelUtil.h>
#include <ZeroDThread.h>
#include <MeasurementGroup.h>

#include <pool/ZeroDCtrl.h>

#include <numeric>

namespace ZeroDExpChannel_ns
{

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::ZeroDExpChannel(string &s)
// 
// description : 	constructor for simulated ZeroDExpChannel
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
ZeroDExpChannel::ZeroDExpChannel(Tango::DeviceClass *cl,string &s)
:Pool_ns::PoolIndBaseDev(cl,s.c_str())
//:Tango::Device_3Impl(cl,s.c_str())
{
	init_cmd = false;
	init_device();
}

ZeroDExpChannel::ZeroDExpChannel(Tango::DeviceClass *cl,const char *s)
:Pool_ns::PoolIndBaseDev(cl,s)
//:Tango::Device_3Impl(cl,s)
{
	init_cmd = false;
	init_device();
}

ZeroDExpChannel::ZeroDExpChannel(Tango::DeviceClass *cl,const char *s,const char *d)
:Pool_ns::PoolIndBaseDev(cl,s,d)
//:Tango::Device_3Impl(cl,s,d)
{
	init_cmd = false;
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::delete_device()
{
	INFO_STREAM << "ZeroDExpChannel::delete_device() " << device_name << endl;
	//	Delete device's allocated object

//
// To know that we are executing this code due to a pool shutdown and not due to a
// "Init" command, we are using the polling thread ptr which is cleared in the DS
// shutdown sequence before the device destruction
//
	bool sd = false;

	Tango::Util *tg = Tango::Util::instance();
	if (tg->get_polling_thread_object() != NULL)
	{
		if (get_state() == Tango::MOVING)
		{
			TangoSys_OMemStream o;
			o << "Init command on 0D channel device is not allowed while a 0D channel is counting" << ends;

			Tango::Except::throw_exception((const char *)"ZeroDExp_InitNotAllowed",o.str(),
				  	(const char *)"ZeroDExpChannel::delete_device");
		}
	}
	else
	{
		sd = true;
	}

	if (save_atts != NULL)
		delete save_atts;
	
//
// If we are not in a shutdown sequence:
// Lock the ghost group in order the polling thread not to
// start requesting for motor state while we are deleting it and
// inform ghost group that there is one channel less
//
// If we are called due to a Init command on the DServer admin,
// the measurement_group class is already deleted and the ghost group
// as well
//

	if (sd == false)
	{
		bool measurementgroup_class_deleted = false;
		MeasurementGroup_ns::MeasurementGroup *ghost_ptr;
		
		try
		{
			ghost_ptr = pool_dev->get_ghost_measurement_group_ptr();
		}
		catch (Tango::DevFailed &e)
		{
			measurementgroup_class_deleted = true;
		}
		
		if (measurementgroup_class_deleted == false)
		{
			Tango::AutoTangoMonitor atm(ghost_ptr);
			ghost_ptr->remove_channel_from_ghost_group(channel_id);
		}
	}
				
//
// Delete the device from its controller and from the pool
//
	the_shared_data.read_values.clear();
	the_shared_data.acq_dates.clear();
	
	delete_from_pool();
	delete_utils();
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::init_device()
{
	INFO_STREAM << "ZeroDExpChannel::ZeroDExpChannel() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();
	
	set_state(Tango::ON);
	string &_status = get_status();
	_status = StatusNotSet;
	
//
// If we are called due to a init command, re-init variables in the
// base class
//

	if (init_cmd == true)
		base_init();

//
// Init some variables
//

	save_atts = NULL;
	read_value  = 0.0;
	cum_read_value = 0.0;
	cum_nb = 0;
	cum_err = 0;
	th = NULL;
	
	if (init_cmd == false)
	{
		attr_CumulationType_write = Pool_ns::AVERAGE;
		attr_CumulationTime_write = 0.0;
	}
	
	Tango::WAttribute &acq_att = dev_attr->get_w_attr_by_name("CumulationType");
	acq_att.set_write_value((long)Pool_ns::AVERAGE);
		
	attr_SimulationMode_read = &simu;
	attr_Value_read = &read_value;
	attr_CumulatedValue_read = &cum_read_value;
	attr_CumulationType_read = &attr_CumulationType_write;
	attr_CumulatedPointsNumber_read = &cum_nb;
	attr_CumulatedPointsError_read = &cum_err;
	attr_CumulationTime_read = &attr_CumulationTime_write;
	
	the_shared_data.error_nb = 0;
	the_shared_data.cont_error = continueOnError;
	the_shared_data.stop_if_no_time = stopIfNoTime;
	the_shared_data.i_am_dead = false;
	
//
// We will push change event on State and Cumulated Value attributes
//

	Tango::Attribute &state_att = dev_attr->get_attr_by_name("state");
	state_att.set_change_event(true,false);
	
	Tango::Attribute &val_att = dev_attr->get_attr_by_name("CumulatedValue");
	val_att.set_change_event(true);
		
//
// Build the PoolBaseUtils class depending on the
// controller type
//

	set_utils(new ZeroDExpChannelUtil(pool_dev));
	
//
// Inform Pool of our birth
//

	Pool_ns::ZeroDExpChannelPool ctp;
	init_pool_element(&ctp);
	
	
	
	{
		Tango::AutoTangoMonitor atm(pool_dev);	
		pool_dev->add_zerod(ctp);
	}

//
// Inform controller of our birth
//

	a_new_child(ctp.ctrl_id);
	
//
// If we are called due to a init command, update our info in the
// ghost group
//
		
	if (init_cmd == true)
	{
		MeasurementGroup_ns::MeasurementGroup *ghost_ptr = pool_dev->get_ghost_measurement_group_ptr();
		{
			Tango::AutoTangoMonitor atm(ghost_ptr);
			ghost_ptr->add_zerod_to_ghost_group(channel_id);
		}
		init_cmd = false;
	}
	
}

void ZeroDExpChannel::init_pool_element(Pool_ns::PoolElement *pe)
{
	PoolIndBaseDev::init_pool_element(pe);
	
	Pool_ns::ZeroDExpChannelPool *ctp = 
		static_cast<Pool_ns::ZeroDExpChannelPool *>(pe);
	
	ctp->zerod_channel = this;
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Channel_id"));
	dev_prop.push_back(Tango::DbDatum("StopIfNoTime"));
	dev_prop.push_back(Tango::DbDatum("ContinueOnError"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	ZeroDExpChannelClass	*ds_class =
		(static_cast<ZeroDExpChannelClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize Channel_id from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  channel_id;
	//	Try to initialize Channel_id from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  channel_id;
	//	And try to extract Channel_id value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  channel_id;

	//	Try to initialize StopIfNoTime from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  stopIfNoTime;
	//	Try to initialize StopIfNoTime from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  stopIfNoTime;
	//	And try to extract StopIfNoTime value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stopIfNoTime;

	//	Try to initialize ContinueOnError from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  continueOnError;
	//	Try to initialize ContinueOnError from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  continueOnError;
	//	And try to extract ContinueOnError value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  continueOnError;



	//	End of Automatic code generation
	//------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::always_executed_hook()
{
	Tango::DevState old_state = get_state();
	
	if (old_state != Tango::MOVING)
	{
		bool th_dead;	
		{
			omni_mutex_lock lo(the_mutex);
			th_dead = the_shared_data.i_am_dead;
		}

//
// If the thread is dead,reclaim its memory
//
	
		if ((th_dead == true) && (th != NULL))
		{
			void *ptr;		
			th->join(&ptr);
			th = NULL;
		}
		
		base_always_executed_hook(false,false);
		Tango::DevState local_state = get_state();
		if ((local_state != Tango::ON) && 
		    (local_state != Tango::FAULT) &&
		    (local_state != Tango::UNKNOWN))
		{
			set_state(Tango::FAULT);
			unknown_state = true;
		}
	}
	
	inform_ghost(old_state,get_state());
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::inform_ghost
// 
// description : 	inform ghost group of a change in the state
//
//-----------------------------------------------------------------------------

void ZeroDExpChannel::inform_ghost(Tango::DevState old_state,Tango::DevState new_state)
{

	if (old_state != Tango::MOVING)
	{	
		if(old_state != new_state && 
	       new_state != Tango::ON &&
	       new_state != Tango::MOVING)
		{
			MeasurementGroup_ns::MeasurementGroup *ghost = pool_dev->get_ghost_measurement_group_ptr();
			long idx = ghost->get_ind_elt_idx_from_id(channel_id);
			Tango::AutoTangoMonitor synch(ghost);
			ghost->update_state_from_ctrls(idx,new_state);
		}
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "ZeroDExpChannel::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_TimeBuffer
// 
// description : 	Extract real attribute values for TimeBuffer acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_TimeBuffer(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::read_TimeBuffer(Tango::Attribute &attr) entering... "<< endl;

	long len = the_shared_data.acq_dates.size();
	
	attr_TimeBuffer_read = new Tango::DevDouble[len];
	
	{	
		omni_mutex_lock lo(the_mutex);
		vector<double>::iterator ite = the_shared_data.acq_dates.begin();
		long l = 0;
		for(;ite != the_shared_data.acq_dates.end();ite++)
		{
			attr_TimeBuffer_read[l++] = (*ite);
		}
	}
	
	attr.set_value(attr_TimeBuffer_read,len,0,true);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_ValueBuffer
// 
// description : 	Extract real attribute values for ValueBuffer acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_ValueBuffer(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::read_ValueBuffer(Tango::Attribute &attr) entering... "<< endl;
	
	long len = the_shared_data.read_values.size();
	
	attr_ValueBuffer_read = new Tango::DevDouble[len];
	
	{	
		omni_mutex_lock lo(the_mutex);
		vector<double>::iterator ite = the_shared_data.read_values.begin();
		long l = 0;
		for(;ite != the_shared_data.read_values.end();ite++)
		{
			attr_ValueBuffer_read[l++] = (*ite);
		}
	}
	
	attr.set_value(attr_ValueBuffer_read,len,0,true);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_CumulationTime
// 
// description : 	Extract real attribute values for CumulationTime acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_CumulationTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::read_CumulationTime(Tango::Attribute &attr) entering... "<< endl;
	
	attr.set_value(attr_CumulationTime_read);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::write_CumulationTime
// 
// description : 	Write CumulationTime attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::write_CumulationTime(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::write_CumulationTime(Tango::WAttribute &attr) entering... "<< endl;
	double tmp_time;
	attr.get_write_value(tmp_time);
	
	if (tmp_time < 0.0)
	{			
		Tango::Except::throw_exception((const char *)"ZeroDExpChannel_CantSetCumulationTime",
									   (const char *)"The value you sent for the Cumulation Time is not valid. It cannot be negative",
							 			(const char *)"ZeroDExpChannel::write_CumulationTime");	
	}		
	attr_CumulationTime_write = tmp_time;

//
// The CumulationTime attribute is a memorized attribute. If we are in simulatioin mode,
// reset the value stored in db to the value it had when the simulation mode
// was set to true
//
	
	if (simu == true)
	{
		try
		{
			Tango::DbDevice *db_dev = get_db_device();
			Tango::DbDatum off("__value");
			Tango::DbDatum att("CumulationTime");
			Tango::DbData db_data;

			short nb_att = 1;
			att << nb_att;		
			off << save_atts->simu_time;
			db_data.push_back(att);
			db_data.push_back(off);
			db_dev->put_attribute_property(db_data);
		}
		catch (Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
			throw;
		}
	}
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_CumulatedPointsNumber
// 
// description : 	Extract real attribute values for CumulatedPointsNumber acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_CumulatedPointsNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::read_CumulatedPointsNumber(Tango::Attribute &attr) entering... "<< endl;

	if (simu == false)
	{
		omni_mutex_lock lo(the_mutex);
		cum_nb = the_shared_data.read_values.size();
	}
	else
		cum_nb = 0;
		
	attr.set_value(attr_CumulatedPointsNumber_read);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_CumulatedPointsError
// 
// description : 	Extract real attribute values for CumulatedPointsError acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_CumulatedPointsError(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::read_CumulatedPointsError(Tango::Attribute &attr) entering... "<< endl;

	if (simu == false)	
	{
		omni_mutex_lock lo(the_mutex);
		cum_err = the_shared_data.error_nb;
	}
	else
		cum_err = 0;
				
	attr.set_value(attr_CumulatedPointsError_read);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_CumulationType
// 
// description : 	Extract real attribute values for CumulationType acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_CumulationType(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::read_CumulationType(Tango::Attribute &attr) entering... "<< endl;
	
	attr.set_value(attr_CumulationType_read);
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::write_CumulationType
// 
// description : 	Write CumulationType attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::write_CumulationType(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::write_CumulationType(Tango::WAttribute &attr) entering... "<< endl;
	
	Tango::DevLong tmp_cum_type;	
	attr.get_write_value(tmp_cum_type);

//
// Check input value
//	

	if ((tmp_cum_type < 0) || (tmp_cum_type >= Pool_ns::numCumType ))
	{
		TangoSys_OMemStream o;
		o << "The value you sent for the Cumulation Type is not valid.";
		o << " It has to be a value between 0 and " << Pool_ns::numCumType - 1 << ends;
			
		Tango::Except::throw_exception((const char *)"ZeroDExpChannel_CantSetCumulationType",o.str(),
							 			(const char *)"ZeroDExpChannel::write_CumulationType");		
	}
	
	if (tmp_cum_type == Pool_ns::INTEGRAL)
	{
		Tango::Except::throw_exception((const char *)"ZeroDExpChannel_CantSetCumulationType",
									   (const char *)"Sorry, the Integral cumulation type is not already implemented",
							 			(const char *)"ZeroDExpChannel::write_CumulationType");	
	}	
	attr_CumulationType_write = tmp_cum_type;
	
//
// Do what we have to do according to the value sent
//

	switch(attr_CumulationType_write)
	{
		case Pool_ns::AVERAGE:
		cout << "Average cumulation type requested" << endl;
		break;
		
		case Pool_ns::SUM:
		cout << "Sum cumulation type requested" << endl;
		break;
		
		case Pool_ns::INTEGRAL:
		cout << "Integral cumulation type requested" << endl;
		break;
	}
	
//
// The CumulationType attribute is a memorized attribute. If we are in simulatioin mode,
// reset the value stored in db to the value it had when the simulation mode
// was set to true
//
	
	if (simu == true)
	{
		try
		{
			Tango::DbDevice *db_dev = get_db_device();
			Tango::DbDatum off("__value");
			Tango::DbDatum att("CumulationType");
			Tango::DbData db_data;

			short nb_att = 1;
			att << nb_att;		
			off << save_atts->simu_type;
			db_data.push_back(att);
			db_data.push_back(off);
			db_dev->put_attribute_property(db_data);
		}
		catch (Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
			throw;
		}
	}
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_CumulatedValue
// 
// description : 	Extract real attribute values for CumulatedValue acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_CumulatedValue(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::read_CumulatedValue(Tango::Attribute &attr) entering... "<< endl;

	ShData local_data;

	if (attr_CumulationType_write == Pool_ns::NO_COMPUTATION)
	{
		Tango::Except::throw_exception((const char *)"ZeroDExpChannel_NoComputation",
		  (const char *)"When CumulationType == NO_COMPUTATION it is not possible to read the CumulatedValue",
		  (const char *)"ZeroDExpChannel::read_CumulatedValue");
	}

	if (simu == false)
	{	
			
//
// If we are acquring data, get values from the thread
//
	
		{
			omni_mutex_lock lo(the_mutex);
			local_data = the_shared_data;
		}
			
//
// Throw exception if the thread only gets error while reading the controller
//

		if (local_data.read_values.size() == 0)
		{
			if (local_data.error_nb != 0)
			{
				Tango::Except::throw_exception((const char *)"ZeroDExpChannel_BadController",
				  (const char *)"Up to now, it has not been possible to get any value from the device",
				  (const char *)"ZeroDExpChannel::read_CumulatedValue");
			}
			else
			{
				Tango::Except::throw_exception((const char *)"ZeroDExpChannel_BadController",
				  (const char *)"No data available yet. No acquisition started yet.",
				  (const char *)"ZeroDExpChannel::read_CumulatedValue");
			}
		}
		else
		{
			
//
// Compute value according to acquisition type
//

			switch (attr_CumulationType_write)
			{
				case Pool_ns::AVERAGE:
				cum_read_value = accumulate(local_data.read_values.begin(),local_data.read_values.end(),0.0);
				cum_read_value = cum_read_value / local_data.read_values.size();
				break;
			
				case Pool_ns::SUM:
				cum_read_value = accumulate(local_data.read_values.begin(),local_data.read_values.end(),0.0);
				break;
				
				case Pool_ns::ONE_SHOT:
				cum_read_value = local_data.read_values[0];
			}
		}
	}
	else
	{
		cum_read_value = 0.0;
	}
	
	attr.set_value(attr_CumulatedValue_read);

//
// Set attribuute quality factor
//
	
	if (get_state() == Tango::MOVING)
		attr.set_quality(Tango::ATTR_CHANGING);
	else
	{
		if (local_data.error_nb != 0)
			attr.set_quality(Tango::ATTR_ALARM);
	}
}


//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_Value
// 
// description : 	Extract real attribute values for Value acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_Value(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::read_Value(Tango::Attribute &attr) entering... "<< endl;

	if (simu == false)
	{	
			
//
// If we are not acquiring data, returns the value coming from the controller
//

		Pool_ns::AutoPoolLock lo(fica_ptr->get_mon());
	
		try
		{
			ZeroDController *typed_ctrl = static_cast<ZeroDController *>(my_ctrl);
			
			typed_ctrl->PreReadAll();
			typed_ctrl->PreReadOne(ct_idx);
			typed_ctrl->ReadAll();
			read_value = typed_ctrl->ReadOne(ct_idx);
		}
		SAFE_CATCH(fica_ptr->get_name(),"read_Value");
		
		if (isnan(read_value) != 0)
		{
			Tango::Except::throw_exception((const char *)"ZeroDExpChannel_BadController",
				  (const char *)"The Zero D Exp Channel controller class has not re-defined method to read value (readOne(...))",
				  (const char *)"ZeroDExpChannel::read_Value");
		}
	}
	else
	{
		read_value = 0.0;
	}
	
	attr.set_value(attr_Value_read);		
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::read_SimulationMode
// 
// description : 	Extract real attribute values for SimulationMode acquisition result.
//
//-----------------------------------------------------------------------------
void ZeroDExpChannel::read_SimulationMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ZeroDExpChannel::read_SimulationMode(Tango::Attribute &attr) entering... "<< endl;
	
	attr.set_value(attr_SimulationMode_read);
}

//+------------------------------------------------------------------
/**
 *	method:	ZeroDExpChannel::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status description
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString ZeroDExpChannel::dev_status()
{
	Tango::ConstDevString	argout = DeviceImpl::dev_status();
	DEBUG_STREAM << "ZeroDExpChannel::dev_status(): entering... !" << endl;

	//	Add your own code to control device here

	base_dev_status(argout);

//
// Add a message for the acquisition type
//
	

	tmp_status = tmp_status + "\nThe data cumulation type is ";
	switch(attr_CumulationType_write)
	{
		case Pool_ns::AVERAGE:
		tmp_status = tmp_status +  "Average";
		break;
		
		case Pool_ns::SUM:
		tmp_status = tmp_status + "Sum";
		break;
		
		case Pool_ns::INTEGRAL:
		tmp_status = tmp_status + "Integral";
		break;
		
		case Pool_ns::NO_COMPUTATION:
		tmp_status = tmp_status + "No computation";
		break;

		case Pool_ns::ONE_SHOT:
		tmp_status = tmp_status + "One shot";
		break;
	}
	
	argout = tmp_status.c_str();
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	ZeroDExpChannel::start
 *
 *	description:	method to execute "Start"
 *	Start acquiring data
 *
 *
 */
//+------------------------------------------------------------------
void ZeroDExpChannel::start()
{
	DEBUG_STREAM << "ZeroDExpChannel::start(): entering... !" << endl;

	//	Add your own code to control device here

 	Tango::MultiAttribute *dev_attrs = get_device_attr();
 	Tango::Attribute &cumval_att = dev_attrs->get_attr_by_name("CumulatedValue");	
	Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
		
	if (simu == false)
	{
		
//
// Init shared memory
//

		the_shared_data.i_am_dead = false;
		the_shared_data.th_exit = false;
		the_shared_data.error_nb = 0;
		the_shared_data.cum_time = (long)(attr_CumulationTime_write * 1000);
		the_shared_data.cum_type = attr_CumulationType_write;
		the_shared_data.read_values.clear();
		the_shared_data.errors.length(0);
		the_shared_data.acq_dates.clear();
		the_shared_data.fire_event = pool_dev->zeroDNbReadPerEvent;
		the_shared_data.sleep_time.tv_sec = 0;
		the_shared_data.sleep_time.tv_nsec = pool_dev->zeroDThreadLoop_SleepTime * 1000000;
		
//
// Start acquisition thread
//
		
    	th = new ZeroDThread(this,the_mutex,the_shared_data);
 
//
// Change state, clear CumulatedValue attribute quality factor and fire event
//

    	set_state(Tango::MOVING);	
    
 		cumval_att.set_quality(Tango::ATTR_VALID); 		
		state_att.fire_change_event(); 
	}
	else
	{   
   		set_state(Tango::MOVING);	
		state_att.fire_change_event(); 
		
		set_state(Tango::ON);
		state_att.fire_change_event();
		
		if(attr_CumulationType_write != Pool_ns::NO_COMPUTATION)
		{
			read_CumulatedValue(cumval_att);
			cumval_att.fire_change_event();
		} 
	}
}

//+------------------------------------------------------------------
/**
 *	method:	ZeroDExpChannel::abort
 *
 *	description:	method to execute "Abort"
 *	Stop acquiring data
 *
 *
 */
//+------------------------------------------------------------------
void ZeroDExpChannel::abort()
{
	DEBUG_STREAM << "ZeroDExpChannel::stop(): entering... !" << endl;

	//	Add your own code to control device here
	base_abort(true);
}
//+------------------------------------------------------------------
/**
 *	method:	ZeroDExpChannel::base_abort
 *
 *	description:	method to execute "Abort"
 *	Stop acquiring data
 *
 *
 */
//+------------------------------------------------------------------
void ZeroDExpChannel::base_abort(bool send_evt)
{
//
// Do nothing if we are not acquiring
//

	if (th == NULL)
		return;
		
//
// Check if the thread is already dead
//

	bool th_dead;	
	{
		omni_mutex_lock lo(the_mutex);
		th_dead = the_shared_data.i_am_dead;
	}

//
// If the thread is not already dead, kill it
//
	
	if (th_dead == false)
	{
		{
			omni_mutex_lock lo(the_mutex);
			the_shared_data.th_exit = true;
		}
	}

	void *ptr;		
	th->join(&ptr);
	th = NULL;

//
// Change state and send event
	
	set_state(Tango::ON);
	
	if(send_evt)
	{
	 	Tango::MultiAttribute *dev_attrs = get_device_attr();
		Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
		state_att.fire_change_event();
		
	//
	// Send event for the last Cumulated value
	//
	
		if(attr_CumulationType_write != Pool_ns::NO_COMPUTATION &&
		   attr_CumulationType_write != Pool_ns::ONE_SHOT)
		{
			Tango::Attribute &cum_val_att = dev_attrs->get_attr_by_name("CumulatedValue");	
			read_CumulatedValue(cum_val_att);
			cum_val_att.fire_change_event();
		}
	}
}

ZeroDExpChannel::Simu_data::Simu_data(ZeroDExpChannel *chan):channel(chan)
{
	Tango::AutoTangoMonitor atm(channel);
	
	simu_time = channel->attr_CumulationTime_write;
	simu_type = channel->attr_CumulationType_write;
}

ZeroDExpChannel::Simu_data::~Simu_data()
{
	Tango::AutoTangoMonitor atm(channel);
	
	Tango::MultiAttribute *ma_ptr = channel->get_device_attr();
	
	if (channel->attr_CumulationTime_write != simu_time)
	{
		channel->attr_CumulationTime_write = simu_time;
		Tango::WAttribute &att = ma_ptr->get_w_attr_by_name("CumulationTime");
		att.set_write_value(simu_time);
	}
	
	if (channel->attr_CumulationType_write != simu_type)
	{
		channel->attr_CumulationType_write = simu_type;
		Tango::WAttribute &att = ma_ptr->get_w_attr_by_name("CumulationType");
		att.set_write_value(simu_type);
	}
}

//+----------------------------------------------------------------------------
//
// method : 		ZeroDExpChannel::get_pool_obj
// 
// description : 	gets Pool 0D experiment channel object for this 0D experiment
//                  channel.
//                  Warning: the following method should only be executed
//                  when the running thread has a lock on the Pool
//
// \return the pool 0D experiment channel object
//-----------------------------------------------------------------------------

Pool_ns::PoolElement &ZeroDExpChannel::get_pool_obj()
{ 
	return pool_dev->get_exp_channel_from_id(channel_id); 
}

}	//	namespace
