//=============================================================================
//
// file :        MeasurementGroup.h
//
// description : Include for the MeasurementGroup class.
//
// project :	MeasurementGroup
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.29  2007/09/08 10:33:45  tcoutinho
// bug fixes
//
// Revision 1.28  2007/09/07 15:00:07  tcoutinho
// safety commit
//
// Revision 1.27  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.26  2007/08/24 15:55:26  tcoutinho
// safety weekend commit
//
// Revision 1.25  2007/08/17 13:07:29  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
// Revision 1.24  2007/07/26 10:25:15  tcoutinho
// - Fix bug 1 :  Automatic temporary MotorGroup/MeasurementGroup deletion
//
// Revision 1.23  2007/07/26 07:05:42  tcoutinho
// fix bug 10 : Change all tango commands from Stop to Abort
//
// Revision 1.22  2007/07/24 07:11:06  tcoutinho
// fix bug: in data acquisition with a measurement it is necessary to check the state of the master channel in order to know when to stop all other channels
//
// Revision 1.21  2007/07/23 16:41:38  tcoutinho
// fix bug: Stop all channels when master stops during acquisition
//
// Revision 1.20  2007/06/26 12:34:20  tcoutinho
// fix bug with swapped channels
//
// Revision 1.19  2007/05/30 14:39:23  etaurel
// - init_cmd still defined in MeasurementGroup class while it is also defined
// in PoolBaseGroupDev class...
//
// Revision 1.18  2007/05/25 12:48:10  tcoutinho
// fix the same dead locks found on motor system to the acquisition system since release labeled for Josep Ribas
//
// Revision 1.17  2007/05/16 16:26:21  tcoutinho
// - fix dead lock
//
// Revision 1.16  2007/04/30 15:47:05  tcoutinho
// - new attribute "Channels"
// - new device property "Channel_List"
// - when add/remove channel, pool sends a change event on the MeasurementGroupList
//
// Revision 1.15  2007/04/23 15:17:59  tcoutinho
// - changes according to Sardana metting 26-03-2007: identical measurement groups can be created, Add/Remove  Exp. channel from a MG, etc
//
// Revision 1.14  2007/04/03 07:17:05  tcoutinho
// - following decision made on Sardana metting 26-03-2007, the save config feature will not be implemented on a measurement group basis.
//
// Revision 1.13  2007/04/03 07:07:13  tcoutinho
// - bug fix on 0D channels
//
// Revision 1.12  2007/03/02 16:33:11  tcoutinho
// - fix bugs - event related, attribute quality, etc
//
// Revision 1.11  2007/03/01 13:12:18  tcoutinho
// - measurement group event related fixes
//
// Revision 1.10  2007/02/28 16:21:52  tcoutinho
// - support for 0D channels
// - basic fixes after running first battery of tests on measurement group
//
// Revision 1.9  2007/02/22 11:56:22  tcoutinho
// - added support for ghost measurement group
// - added support for init/reload controller operations
// - fix some possible concurrency
// - added support for configuration (not finished)
//
// Revision 1.8  2007/02/16 10:01:16  tcoutinho
// - development checkin
//
// Revision 1.7  2007/02/13 14:39:42  tcoutinho
// - fix bug in motor group when a motor or controller are recreated due to an InitController command
//
// Revision 1.6  2007/02/08 16:18:13  tcoutinho
// - controller safety on PoolGroupBaseDev
//
// Revision 1.5  2007/02/07 16:53:05  tcoutinho
// safe guard commit
//
// Revision 1.4  2007/02/06 19:36:51  tcoutinho
// safe guard commit
//
// Revision 1.3  2007/02/06 19:11:23  tcoutinho
// safe guard commit
//
// Revision 1.2  2007/02/06 09:42:34  tcoutinho
// - safe development commit
//
// Revision 1.1  2007/02/03 15:20:39  tcoutinho
// - new Measurement Group Tango device
//
//
// copyleft :    European Synchrotron Radiation Facility
//               BP 220, Grenoble 38043
//               FRANCE
//
//=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================
#ifndef _MEASUREMENTGROUP_H
#define _MEASUREMENTGROUP_H

#include <PoolDef.h>
#include <PoolGroupBaseDev.h>

namespace Pool_ns
{
	class Pool;
	struct CTExpChannelPool;
	struct ZeroDExpChannelPool;
	struct PseudoCounterPool;
}

/**
 * @author	$Author$
 * @version	$Revision$
 */

 //	Add your own constants definitions here.
 //-----------------------------------------------

class CoTiController;
class ZeroDController;
class PseudoCounterController;

#define		DYN_ATTR_SUFIX		"_value"
#define		ALARM_STATUS_MSG	"The measurement group definition is not correct (No Timer/Monitor defined)"

/**
 * @namespace MeasurementGroup_ns
 * 
 * @brief The namespace for the measurement group tango class.
 * 
 * @author	tcoutinho 
 */
namespace MeasurementGroup_ns
{

class MeasurementGroup;

/**
 * Class Description:
 * A Measurement Group Device used by the Sardana project device pool
 */

/*
 *	Device States Description:
*  Tango::ON :       The Measurement Group is ON and waiting
*  Tango::MOVING :   The Measurement Group is counting
*  Tango::FAULT :    A fault has been reported by the device controller of at least one of the elements
*  Tango::ALARM :    The MeasurementGroup configuration is not correct (No Timer/Monitor defined)
*  Tango::UNKNOWN :  An exception has been thrown when communicating with the components controllers.
 */


class MeasurementGroup: public Pool_ns::PoolGroupBaseDev
{
public :
	//	Add your own data members here
	//-----------------------------------------

	//	Here is the Start of the automatic code generation part
	//-------------------------------------------------------------	
/**
 *	@name attributes
 *	Attributs member data.
 */
//@{
		Tango::DevLong	*attr_Integration_count_read;
		Tango::DevLong	attr_Integration_count_write;
		Tango::DevDouble	*attr_Integration_time_read;
		Tango::DevDouble	attr_Integration_time_write;
		Tango::DevString	*attr_Monitor_read;
		Tango::DevString	attr_Monitor_write;
		Tango::DevString	*attr_Timer_read;
		Tango::DevString	attr_Timer_write;
		Tango::DevString	*attr_ZeroDExpChannels_read;
		Tango::DevString	*attr_OneDExpChannels_read;
		Tango::DevString	*attr_TwoDExpChannels_read;
		Tango::DevString	*attr_Counters_read;
		Tango::DevString	*attr_Channels_read;
		Tango::DevString	*attr_PseudoCounters_read;
//@}

/**
 *	@name Device properties
 *	Device properties member data.
 */
//@{
/**
 *	The measurement group identifier device in the sardana device pool
 */
	Tango::DevLong	measurement_group_id;
/**
 *	List of user channels in this measurement group
 */
	vector<string>	user_group_elt;
/**
 *	List of counter/timers in this measurement group
 */
	vector<string>	ct_List;
/**
 *	List of 0D Experiment Channels in this measurement group
 */
	vector<string>	zeroDExpChannel_List;
/**
 *	List of 1D Experiment Channels in this measurement group
 */
	vector<string>	oneDExpChannel_List;
/**
 *	List of 2D Experiment Channels in this measurement group
 */
	vector<string>	twoDExpChannel_List;
/**
 *	List of physical channels in this measurement group
 */
	vector<string>	phys_group_elt;
/**
 *	list of pseudo counters in this measurement group
 */
	vector<string>	pseudoCounter_List;
//@}

/**@name Constructors
 * Miscellaneous constructors */
//@{
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
	MeasurementGroup(Tango::DeviceClass *cl,string &s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
	MeasurementGroup(Tango::DeviceClass *cl,const char *s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device name
 *	@param d	Device description.
 */
	MeasurementGroup(Tango::DeviceClass *cl,const char *s,const char *d);
//@}

/**@name Destructor
 * Only one desctructor is defined for this class */
//@{
/**
 * The object desctructor.
 */	
	~MeasurementGroup() {delete_device();};
/**
 *	will be called at device destruction or at init command.
 */
	void delete_device();
//@}

	
/**@name Miscellaneous methods */
//@{
/**
 *	Initialize the device
 */
	virtual void init_device();
/**
 *	Always executed method befor execution command method.
 */
	virtual void always_executed_hook();

//@}

/**
 * @name MeasurementGroup methods prototypes
 */

//@{
/**
 *	Hardware acquisition for attributes.
 */
	virtual void read_attr_hardware(vector<long> &attr_list);
/**
 *	Extract real attribute values for Integration_count acquisition result.
 */
	virtual void read_Integration_count(Tango::Attribute &attr);
/**
 *	Write Integration_count attribute values to hardware.
 */
	virtual void write_Integration_count(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Integration_time acquisition result.
 */
	virtual void read_Integration_time(Tango::Attribute &attr);
/**
 *	Write Integration_time attribute values to hardware.
 */
	virtual void write_Integration_time(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Monitor acquisition result.
 */
	virtual void read_Monitor(Tango::Attribute &attr);
/**
 *	Write Monitor attribute values to hardware.
 */
	virtual void write_Monitor(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for Timer acquisition result.
 */
	virtual void read_Timer(Tango::Attribute &attr);
/**
 *	Write Timer attribute values to hardware.
 */
	virtual void write_Timer(Tango::WAttribute &attr);
/**
 *	Extract real attribute values for ZeroDExpChannels acquisition result.
 */
	virtual void read_ZeroDExpChannels(Tango::Attribute &attr);
/**
 *	Extract real attribute values for OneDExpChannels acquisition result.
 */
	virtual void read_OneDExpChannels(Tango::Attribute &attr);
/**
 *	Extract real attribute values for TwoDExpChannels acquisition result.
 */
	virtual void read_TwoDExpChannels(Tango::Attribute &attr);
/**
 *	Extract real attribute values for Counters acquisition result.
 */
	virtual void read_Counters(Tango::Attribute &attr);
/**
 *	Extract real attribute values for Channels acquisition result.
 */
	virtual void read_Channels(Tango::Attribute &attr);
/**
 *	Extract real attribute values for PseudoCounters acquisition result.
 */
	virtual void read_PseudoCounters(Tango::Attribute &attr);
/**
 *	Read/Write allowed for Integration_count attribute.
 */
	virtual bool is_Integration_count_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Integration_time attribute.
 */
	virtual bool is_Integration_time_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Monitor attribute.
 */
	virtual bool is_Monitor_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Timer attribute.
 */
	virtual bool is_Timer_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for ZeroDExpChannels attribute.
 */
	virtual bool is_ZeroDExpChannels_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for OneDExpChannels attribute.
 */
	virtual bool is_OneDExpChannels_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for TwoDExpChannels attribute.
 */
	virtual bool is_TwoDExpChannels_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Counters attribute.
 */
	virtual bool is_Counters_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for Channels attribute.
 */
	virtual bool is_Channels_allowed(Tango::AttReqType type);
/**
 *	Read/Write allowed for PseudoCounters attribute.
 */
	virtual bool is_PseudoCounters_allowed(Tango::AttReqType type);
/**
 *	Execution allowed for Start command.
 */
	virtual bool is_Start_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for Abort command.
 */
	virtual bool is_Abort_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for AddExpChannel command.
 */
	virtual bool is_AddExpChannel_allowed(const CORBA::Any &any);
/**
 *	Execution allowed for RemoveExpChannel command.
 */
	virtual bool is_RemoveExpChannel_allowed(const CORBA::Any &any);
/**
 * This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *	@return	State Code
 *	@exception DevFailed
 */
	virtual Tango::DevState	dev_state();
/**
 * Start counting using the active configuration
 *	@exception DevFailed
 */
	void	start();
/**
 * Abort the acquisition
 *	@exception DevFailed
 */
	void	abort();
/**
 * Append a new experiment channel to the current list of channels in the measurement group.
 *	@param	argin	Experiment Channel name
 *	@exception DevFailed
 */
	void	add_exp_channel(Tango::DevString);
/**
 * Removes the experiment channel from the list of experiment channels in the measurement group
 *	@param	argin	Experiment channel name
 *	@exception DevFailed
 */
	void	remove_exp_channel(Tango::DevString);

/**
 *	Read the device properties from database
 */
	 void get_device_property();
//@}

	//	Here is the end of the automatic code generation part
	//-------------------------------------------------------------	

//
// Methods and data members for dynamic attributes
//

	void create_dyn_attr();
	void create_one_extra_attr(string &, Pool_ns::MntGrpEltType, bool change_event = true);
	void remove_unwanted_dyn_attr_from_device();
	
	map<string,double*>		spectrum_data;
	map<string,double*>		image_data;
	
	bool is_ExtraAttr_allowed(Tango::AttReqType type);
	
	void read_CT_Attr(Tango::Attribute &attr);
	void read_0D_Attr(Tango::Attribute &attr);		
	void read_1D_Attr(Tango::Attribute &attr);
	void read_2D_Attr(Tango::Attribute &attr);
	void read_PC_Attr(Tango::Attribute &attr);

	void abort_all_channels(vector<Tango::DevFailed> &);
	
	////////////////////////////////////////////////////
	// C O N T R O L L E R S
	////////////////////////////////////////////////////
	
	/**
	 * Generic Channel controller structure
	 */
	struct ChCtrlInGrp : public Pool_ns::CtrlGrp
	{
		ChCtrlInGrp(Pool_ns::ControllerPool &ref,
					Tango::Device_3Impl *dev = NULL): 
			Pool_ns::CtrlGrp(ref, dev) {}
		virtual ~ChCtrlInGrp() {}
		
		virtual void PreReadAll() = 0;
		virtual void ReadAll() = 0;
		
	};
	
	/**
	 * Pseudo counter controller structure
	 */

	struct PseudoCoCtrlInGrp : public ChCtrlInGrp
	{
		PseudoCoCtrlInGrp(Pool_ns::ControllerPool &ref,
						  Tango::Device_3Impl *dev = NULL): 
			ChCtrlInGrp(ref, dev) {}

		virtual ~PseudoCoCtrlInGrp() {}
		
		virtual void PreReadAll()		{ }
		virtual void ReadAll()			{ }
	
		PseudoCounterController *get_pc_ctrl();
	};
	
	/**
	 * Counter/Timer controller structure
	 */

	struct CTCtrlInGrp : public ChCtrlInGrp
	{
		CTCtrlInGrp(Pool_ns::ControllerPool &ref,
					Tango::Device_3Impl *dev = NULL): 
			ChCtrlInGrp(ref, dev) {}
		
		virtual ~CTCtrlInGrp() {}
		
		virtual void PreReadAll();
		virtual void ReadAll();
	
		CoTiController *get_ct_ctrl();
	};
	
	/**
	 * 0D Experiment channel controller structure
	 */
	struct ZeroDCtrlInGrp : public ChCtrlInGrp
	{
		ZeroDCtrlInGrp(Pool_ns::ControllerPool &ref,
					   Tango::Device_3Impl *dev = NULL): 
			ChCtrlInGrp(ref, dev) {}

		virtual ~ZeroDCtrlInGrp() {}
		
		virtual void PreReadAll();
		virtual void ReadAll();
	
		ZeroDController *get_zerod_ctrl();
	};

	/**
	 * 1D Experiment channel controller structure
	 */
	struct OneDCtrlInGrp : public ChCtrlInGrp
	{
		OneDCtrlInGrp(Pool_ns::ControllerPool &ref,
					  Tango::Device_3Impl *dev = NULL): 
			ChCtrlInGrp(ref, dev) {}

		virtual ~OneDCtrlInGrp() {}
		
		virtual void PreReadAll();
		virtual void ReadAll();
		
		//TODO Change to 1D
		ZeroDController *get_oned_ctrl();
	};

	/**
	 * 2D Experiment channel controller structure
	 */
	struct TwoDCtrlInGrp : public ChCtrlInGrp
	{
		TwoDCtrlInGrp(Pool_ns::ControllerPool &ref,
					  Tango::Device_3Impl *dev = NULL): 
			ChCtrlInGrp(ref, dev) {}

		virtual ~TwoDCtrlInGrp() {}
		
		virtual void PreReadAll();
		virtual void ReadAll();
		
		//TODO Change to 2D
		ZeroDController *get_twod_ctrl();
	};

	////////////////////////////////////////////////////
	// C H A N N E L S
	////////////////////////////////////////////////////

	/**
	 * Generic Channel structure
	 */
	struct ChInGrp: public Pool_ns::IndEltGrp
	{
		long attr_idx;
		
		virtual Pool_ns::MntGrpEltType get_type() = 0;
		
		ChInGrp(Pool_ns::PoolElement &ref,
				Pool_ns::CtrlGrp *ctrl_ptr, long grp,
				Tango::Device_3Impl *dev = NULL): 
			Pool_ns::IndEltGrp(ref, ctrl_ptr, grp, dev),
			attr_idx(-1) {}
		virtual ~ChInGrp() {}
		
		virtual void PreReadOne() = 0;
		virtual void ReadOne() = 0;
	};
	
	/**
	 * A generic channel structure representing a single value channel. 
	 * This is useful to provide a common super class for counter/timer, 0D and
	 * pseudo counter channels
	 */
	struct SingleValChInGrp: public ChInGrp
	{
		double value;
		
		vector<SingleValChInGrp*> used_by;	///< counters that use this counter
		vector<SingleValChInGrp*> uses;		///< counters that are used by this counter
		
		SingleValChInGrp(Pool_ns::PoolElement &ref,
				Pool_ns::CtrlGrp *ctrl_ptr, long grp,
						 Tango::Device_3Impl *dev = NULL):
			ChInGrp(ref, ctrl_ptr, grp, dev) {}
		virtual ~SingleValChInGrp() {}
	};
	
	/**
	 * Counter/Timer Channel structure
	 */
	struct CTInGrp: public SingleValChInGrp
	{
		CTInGrp(Pool_ns::CTExpChannelPool &ref, Pool_ns::CtrlGrp *ctrl_ptr,
				long grp, Tango::Device_3Impl *dev = NULL);
		virtual ~CTInGrp() {}
		
		virtual const char *get_family();
		virtual Pool_ns::MntGrpEltType get_type();
		
		virtual void PreReadOne();
		virtual void ReadOne();

		Pool_ns::CTExpChannelPool &get_ct();
	};

	/**
	 * 0D Experiment Channel structure
	 */
	struct ZeroDInGrp: public SingleValChInGrp
	{
		ZeroDInGrp(Pool_ns::ZeroDExpChannelPool &ref,
				Pool_ns::CtrlGrp *ctrl_ptr, long grp,
				Tango::Device_3Impl *dev = NULL);
		virtual ~ZeroDInGrp() {}

	 	virtual const char *get_family();
		virtual Pool_ns::MntGrpEltType get_type();

		virtual void PreReadOne();
		virtual void ReadOne();
	 	
	 	Pool_ns::ZeroDExpChannelPool &get_zerod();
	};

	/**
	 * Pseudo Counter Channel structure
	 */
	struct PseudoCoInGrp: public SingleValChInGrp
	{
		vector<CTInGrp*>		uses_ct;	///< all counter/timers that needed by this pseudo
		vector<ZeroDInGrp*>		uses_0D;	///< all 0Ds that are needed by this pseudo
		vector<PseudoCoInGrp*>	uses_pc;	///< all pseudos that are needed by this pseudo
		bool					is_virtual;	///< true if it does not need any channel

		PseudoCoInGrp(Pool_ns::PseudoCounterPool &ref,
				Pool_ns::CtrlGrp *ctrl_ptr, long grp,
					  Tango::Device_3Impl *dev = NULL);
		virtual ~PseudoCoInGrp() {}
		
		virtual const char *get_family();
		virtual Pool_ns::MntGrpEltType get_type();
		
		virtual void PreReadOne();
		virtual void ReadOne();

		Pool_ns::PseudoCounterPool &get_pc();
	};	
	
	/**
	 * 1D Experiment Channel structure
	 */
	struct OneDInGrp: public ChInGrp
	{
		double *value;
		
		//TODO change to 1D data type
		OneDInGrp(Pool_ns::ZeroDExpChannelPool &ref, 
				Pool_ns::CtrlGrp *ctrl_ptr, long grp,
				Tango::Device_3Impl *dev = NULL);
		virtual ~OneDInGrp() {}
		
		virtual const char *get_family();
		virtual Pool_ns::MntGrpEltType get_type();
		
		//TODO change to 1D data type
		virtual void PreReadOne();
		virtual void ReadOne();
	 	
	 	//TODO change to 1D data type
	 	Pool_ns::ZeroDExpChannelPool &get_oned();
	 	
	};
	
	/**
	 * 2D Experiment Channel structure
	 */
	struct TwoDInGrp: public ChInGrp
	{
		double *value;
		
		//TODO change to 2D data type
		TwoDInGrp(Pool_ns::ZeroDExpChannelPool &ref,
				Pool_ns::CtrlGrp *ctrl_ptr, long grp,
				Tango::Device_3Impl *dev = NULL);
		virtual ~TwoDInGrp() {}
		
		virtual const char *get_family();
		virtual Pool_ns::MntGrpEltType get_type();
		
		virtual void PreReadOne();
		virtual void ReadOne();
		
		//TODO change to 2D data type
	 	Pool_ns::ZeroDExpChannelPool &get_twod();
	};
	
protected :	
	//	Add your own data members here
	//-----------------------------------------
	
	vector<PseudoCoInGrp*>			pseudo_elts;
	vector<PseudoCoCtrlInGrp*> 		implied_pseudo_ctrls;
	long							ct_nb;
	long							zeroD_nb;
	long							oneD_nb;
	long							twoD_nb;
	long							pc_nb;
	
	Pool_ns::AquisitionMode			aq_mode;
	string							timer;
	string							monitor;
	ChInGrp							*master;
	
	bool							first_write_timer;
	bool							first_write_monitor;
	bool							first_write_integration_time;
	bool							first_write_integration_count;

/**
 * Map with key = tango attribute index; value = correponding experiment channel
 */
	map<long,ChInGrp*> attr_channel_map;
	map<string,ChInGrp*> attr_name_channel_map; 
	
	virtual void init_pool_element(Pool_ns::PoolElement *);
	virtual void State_all_ind(vector<Controller *> &);
	virtual void handle_temporary_siblings();
	
	CTInGrp &get_ct_from_index(long);
	ZeroDInGrp &get_zerod_from_index(long);
	OneDInGrp &get_oned_from_index(long);
	TwoDInGrp &get_twod_from_index(long);
	PseudoCoInGrp &get_pc_from_index(long);
	
	CTInGrp *build_ct(Pool_ns::CTExpChannelPool &);
	ZeroDInGrp *build_zerod(Pool_ns::ZeroDExpChannelPool &);
	OneDInGrp *build_oned(/*Pool_ns::OneDExpChannelPool &*/);
	TwoDInGrp *build_twod(/*Pool_ns::TwoDExpChannelPool &*/);
	PseudoCoInGrp *build_pc(Pool_ns::PseudoCounterPool &);
	
	CTCtrlInGrp *build_ct_ctrl(Pool_ns::ControllerPool &);
	ZeroDCtrlInGrp *build_zerod_ctrl(Pool_ns::ControllerPool &);
	OneDCtrlInGrp *build_oned_ctrl(Pool_ns::ControllerPool &);
	TwoDCtrlInGrp *build_twod_ctrl(Pool_ns::ControllerPool &);
	PseudoCoCtrlInGrp *build_pc_ctrl(Pool_ns::ControllerPool &);
	
	void get_limits(Pool_ns::MntGrpEltType,long &,long &);
	
	template<class LongIterator> void read_ct_values_from_ctrls(LongIterator, LongIterator );
	template<class LongIterator> void read_zerod_values_from_ctrls(LongIterator, LongIterator );
	template<class LongIterator> void read_pc_values_from_ctrls(LongIterator, LongIterator );
	
	void update_attr2channel_indexes();
	
	void write_list_props_to_db(string &, vector<string> &);
	
	bool is_elem_only_used_in_pc(PseudoCoInGrp *, SingleValChInGrp *);
public:
	
	CTInGrp &get_ct_from_name(string &);
	ZeroDInGrp &get_zerod_from_name(string &);
	OneDInGrp &get_oned_from_name(string &);
	TwoDInGrp &get_twod_from_name(string &);
	PseudoCoInGrp &get_pc_from_name(string &);
	
	PseudoCoInGrp &get_pc_from_id(long );
	
	ChInGrp &get_channel_from_name(string &);	
	ChInGrp &get_channel_from_id(long ch_id)	
	{ 
		try { return static_cast<ChInGrp&>(get_ind_elt_from_id(ch_id)); }
		catch(Tango::DevFailed &e) { return get_pc_from_id(ch_id); }
	}
	
	Tango::DevDouble *get_ct_data_from_index(long );
	
	Pool_ns::CtrlGrp &get_pc_ctrl_grp_from_id(long, long &);
	
	void read_master();
	void read_values(Pool_ns::MntGrpEltType type = Pool_ns::ANY_CHANNEL);
	
	virtual void build_grp();
	virtual int get_polling_th_id();
	virtual Pool_ns::PoolElement &get_pool_obj();
	virtual long get_id() 			{ return measurement_group_id; }
	virtual void base_abort(bool);
	
	void update_state_from_ctrls(long idx = -1, Tango::DevState state = Tango::ON);
	
	virtual void pool_elem_changed(Pool_ns::PoolElemEventList &evt,Pool_ns::PoolElementEvent &);
	
	void add_ct_to_ghost_group(long);
	void add_zerod_to_ghost_group(long);
	void add_oned_to_ghost_group(long);
	void add_twod_to_ghost_group(long);
		
	void remove_channel_from_ghost_group(long);
};

/**
 * Class Description: A Double, read only, scalar attribute
 * 
 */ 
class Dou_CT_R_Attrib: public Tango::Attr
{
public:
	Dou_CT_R_Attrib(string &name):Attr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ) {};
	~Dou_CT_R_Attrib() {};
	
	
	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
	{(static_cast<MeasurementGroup *>(dev))->read_CT_Attr(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
	{return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

/**
 * Class Description: A Double, read only, scalar attribute
 * 
 */ 
class Dou_PC_R_Attrib: public Tango::Attr
{
public:
	Dou_PC_R_Attrib(string &name):Attr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ) {};
	~Dou_PC_R_Attrib() {};
	
	
	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
	{(static_cast<MeasurementGroup *>(dev))->read_PC_Attr(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
	{return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

/**
 * Class Description: A Double, read only, scalar attribute
 * 
 */ 
class Dou_R_Scl_Attrib: public Tango::Attr
{
public:
	Dou_R_Scl_Attrib(string &name):Attr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ){};
	~Dou_R_Scl_Attrib() {};
	
	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
	{(static_cast<MeasurementGroup *>(dev))->read_0D_Attr(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
	{return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

/**
 * Class Description: A Double, read only, spectrum attribute
 * 
 */ 
class Dou_R_Sptrm_Attrib: public Tango::SpectrumAttr
{
public:
	Dou_R_Sptrm_Attrib(string &name, long max_x):SpectrumAttr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ, max_x){};
	~Dou_R_Sptrm_Attrib() {};
	
	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
	{(static_cast<MeasurementGroup *>(dev))->read_1D_Attr(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
	{return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

/**
 * Class Description: A Double, read only, image attribute
 * 
 */ 
class Dou_R_Img_Attrib: public Tango::ImageAttr
{
public:
	Dou_R_Img_Attrib(string &name, long max_x, long max_y):ImageAttr(name.c_str(), Tango::DEV_DOUBLE, Tango::READ, max_x, max_y){};
	~Dou_R_Img_Attrib() {};
	
	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
	{(static_cast<MeasurementGroup *>(dev))->read_2D_Attr(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
	{return (static_cast<MeasurementGroup *>(dev))->is_ExtraAttr_allowed(ty);}
};

}	// namespace_ns

#endif	// _MEASUREMENTGROUP_H
