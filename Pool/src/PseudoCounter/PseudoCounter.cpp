static const char *RcsId = "$Header$";
//+=============================================================================
//
// file :         PseudoCounter.cpp
//
// description :  C++ source for the PseudoCounter and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                PseudoCounter are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.5  2007/08/30 12:40:39  tcoutinho
// - changes to support Pseudo counters.
//
// Revision 1.4  2007/08/24 15:55:54  tcoutinho
// safety weekend commit
//
// Revision 1.3  2007/08/23 10:33:42  tcoutinho
// - basic pseudo counter check
// - some fixes regarding pseudo motors
//
// Revision 1.2  2007/08/20 06:37:31  tcoutinho
// development commit
//
// Revision 1.1  2007/08/17 13:11:04  tcoutinho
// - pseudo motor restructure
// - pool base dev class restructure
// - initial commit for pseudo counters
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//  Start   |  start()
//  Abort   |  abort()
//
//===================================================================

#include <tango.h>
#include <PseudoCounter.h>
#include <PseudoCounterClass.h>
#include <PseudoCounterUtil.h>
#include <PoolUtil.h>

#include <pool/PseudoCoCtrl.h>

namespace PseudoCounter_ns
{

template<class T>
inline void PRINT_ELEMENTS(const T& coll, const char* optcstr="")
{
	typename T::const_iterator pos;
	cout << optcstr;
	for(pos = coll.begin(); pos != coll.end() ; pos++)
		cout << *pos << ' ';
	cout << endl;
}

//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::PseudoCounter(string &s)
// 
// description : 	constructor for simulated PseudoCounter
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
PseudoCounter::PseudoCounter(Tango::DeviceClass *cl,string &s)
//:Tango::Device_3Impl(cl,s.c_str())
:Pool_ns::PoolIndBaseDev(cl,s.c_str())
{
	init_cmd = false;
	init_device();
}

PseudoCounter::PseudoCounter(Tango::DeviceClass *cl,const char *s)
//:Tango::Device_3Impl(cl,s)
:Pool_ns::PoolIndBaseDev(cl,s)
{
	init_cmd = false;
	init_device();
}

PseudoCounter::PseudoCounter(Tango::DeviceClass *cl,const char *s,const char *d)
//:Tango::Device_3Impl(cl,s,d)
:Pool_ns::PoolIndBaseDev(cl,s,d)
{
	init_cmd = false;
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void PseudoCounter::delete_device()
{
	//	Delete device's allocated object
//
// A trick to inform client(s) listening on events that the pool device is down.
// Without this trick, the clients will have to wait for 3 seconds before being informed 
// This is the Tango device time-out.
// To know that we are executing this code due to a pool shutdown and not due to a
// "Init" command, we are using the polling thread ptr which is cleared in the DS
// shutdown sequence before the device destruction
//

	bool sd = false;
	
	Tango::Util *tg = Tango::Util::instance();
	if (tg->get_polling_thread_object() == NULL)
	{
		sd = true;
	}
	
	for(unsigned long ul = 0; ul < channel_list.size(); ul++)
		if (ch_mov[ul].proxy != NULL) delete ch_mov[ul].proxy;
	delete [] ch_mov;

	if(sd == true)
	{
		SAFE_DELETE_ARRAY(attr_ChannelList_read);
	}
//
// Delete the device from its controller and from the pool
//
	delete_from_pool();
	delete_utils();
}

//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void PseudoCounter::init_device()
{
	INFO_STREAM << "PseudoCounter::PseudoCounter() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();
	
	set_state(Tango::ON);
	string &_status = get_status();
	_status = StatusNotSet;
	
//
// If we are called due to a init command, also re-init variables in the
// base class
//
	if (init_cmd == true)
		base_init();
	else
	{
		unsigned long ch_nb = channel_list.size();
		attr_ChannelList_read = new Tango::DevString[ch_nb];
		ch_values.resize(ch_nb,0.0);
	}
	
	attr_Value_read = &value;
	
//
// We will push change event on State and value attributes
//
	Tango::Attribute &state_att = dev_attr->get_attr_by_name("state");
	state_att.set_change_event(true,false);

	Tango::Attribute &val_att = dev_attr->get_attr_by_name("Value");
	val_att.set_change_event(true);

//
// Build the PoolBaseUtils class depending on the
// controller type
//

	set_utils(new PseudoCounterUtil(pool_dev));
	
//
// Inform Pool of our birth
//

	Pool_ns::PseudoCounterPool pcp;
	init_pool_element(&pcp);
	
	{
		Tango::AutoTangoMonitor atm(pool_dev);	
		pool_dev->add_pseudo_counter(pcp);
	}
	
//
// Inform controller of our birth
//

	if (my_ctrl != NULL)
	{
		a_new_child(pcp.ctrl_id);
	}
	else
		set_state(Tango::FAULT);
	
	ch_mov = new ChannelMov[channel_list.size()];
	for(unsigned long ul = 0; ul < channel_list.size(); ul++)
	{
		ch_mov[ul].proxy = new Tango::DeviceProxy(channel_list[ul]);

		try
		{
			Pool_ns::CTExpChannelPool &ctp = 
				pool_dev->get_ct_from_name(channel_list[ul]);
			ch_mov[ul].type = COUNTER_TIMER;
			ch_mov[ul].id = ctp.id;
			continue;
		}
		catch(Tango::DevFailed &e)
		{}
		
		try
		{
			Pool_ns::ZeroDExpChannelPool &zdp = 
				pool_dev->get_zerod_from_name(channel_list[ul]);
			ch_mov[ul].type = ZEROD;
			ch_mov[ul].id = zdp.id;
			continue;
		}
		catch(Tango::DevFailed &e)
		{}
		
		try
		{
			Pool_ns::PseudoCounterPool &pcp = 
				pool_dev->get_pseudo_counter_from_name(channel_list[ul]);
			ch_mov[ul].type = PSEUDO_COUNTER;
			ch_mov[ul].id = pcp.id;
			continue;
		}
		catch(Tango::DevFailed &e)
		{}
	}
}

void PseudoCounter::init_pool_element(Pool_ns::PoolElement *pe)
{
	PoolIndBaseDev::init_pool_element(pe);
	
	Pool_ns::PseudoCounterPool *pcp = 
		static_cast<Pool_ns::PseudoCounterPool *>(pe);
	
	pcp->pseudo_counter = this;
	
	Tango::AutoTangoMonitor atm(pool_dev);
		
	unsigned long ul = 0;
	unsigned long co_nb = channel_list.size();
	vector<string>::iterator ch_name_ite = channel_list.begin();
	for(;ch_name_ite != channel_list.end() ; ch_name_ite++)
	{
		bool found = false;
		try
		{
			Pool_ns::CTExpChannelPool &ctp = 
									pool_dev->get_ct_from_name((*ch_name_ite));
			pcp->ch_elts.push_back(&ctp);
			found = true;
		}
		catch(Tango::DevFailed &e)
		{}

		if(!found)
		{
			try
			{
				Pool_ns::ZeroDExpChannelPool &zdp = 
								pool_dev->get_zerod_from_name((*ch_name_ite));
				pcp->ch_elts.push_back(&zdp);
				found = true;
			}
			catch(Tango::DevFailed &e)
			{}
		}

		if(!found)
		{
			try
			{
				Pool_ns::PseudoCounterPool &p = 
						pool_dev->get_pseudo_counter_from_name((*ch_name_ite));
				pcp->ch_elts.push_back(&p);
				found = true;
			}
			catch(Tango::DevFailed &e)
			{
				TangoSys_OMemStream o;
				
				o << "No counter/timer, 0D experiment channel or pseudo ";
				o << "counter with name " << (*ch_name_ite) << " found in the ";
				o << "pool" << ends;
				
				Tango::Except::re_throw_exception(e,
					(const char *)"Pool_InvalidPseudoCounterElement",o.str(),
					(const char *)"PseudoCounter::init_pool_element");
			}
		}
		
		pcp->user_full_name_extra += (*ch_name_ite);
		if (ul < co_nb-1)
			pcp->user_full_name_extra += ", ";
		ul++;	
	}
}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 */
//+------------------------------------------------------------------
Tango::DevState PseudoCounter::dev_state()
{
	DEBUG_STREAM << "PseudoCounter::dev_state(): entering... !" << endl;

	update_state_from_channels();
			
	return get_state();
}

void PseudoCounter::update_state_from_channels(long idx, Tango::DevState ch_state)
{	
	if (should_be_in_fault())
	{
		set_state(Tango::FAULT);
	}
	else
	{
		if(idx >= 0)
		{
			
		}
//
// Read state from channels
//
		Tango::DevState final_state = Tango::ON;
		string &_status = get_status();
		_status = StatusNotSet;

		unsigned long ch_nb = channel_list.size();
		for(unsigned long ul = 0; ul < ch_nb; ul++)
		{	
			Tango::DevState st = (idx == ul) ? ch_state : ch_mov[ul].proxy->state();

			ch_mov[ul].state = st;
			
			if(st == Tango::FAULT)
			{
				if (ul != 0)
					_status += '\n';
				_status += channel_list[ul] + " is in FAULT";
				if(final_state == Tango::ON) 
					final_state = Tango::FAULT;
			}
			else if(st == Tango::UNKNOWN)
			{
				if (ul != 0)
					_status += '\n';
				_status += channel_list[ul] + " is in UNKNOWN state";
				if(final_state == Tango::ON || final_state == Tango::FAULT) 
					final_state = Tango::UNKNOWN;
			}
			else if(st == Tango::ALARM)
			{
				if (ul != 0)
					_status += '\n';
				_status += channel_list[ul] + " is in ALARM state";
				if(final_state != Tango::MOVING)
					final_state = Tango::ALARM;
			}			
			else if(st == Tango::MOVING)
			{
				if (ul != 0)
					_status += '\n';
				_status += channel_list[ul] + " is in ALARM state";
				final_state = Tango::MOVING;
			}			
		}
		set_state(final_state);
	}
}

PseudoCounter::ChannelMov &PseudoCounter::get_ch_from_id(long id)
{
	unsigned long ch_nb = channel_list.size();
	for(unsigned long ul = 0; ul < ch_nb; ul++)
	{	
		if(ch_mov[ul].id == id)
			return ch_mov[ul];
	}
	
	TangoSys_OMemStream o;
	o << "The pseudo counter does not contain the channel with id "<< id << ends;
	Tango::Except::throw_exception(
			(const char *)"PseudoCounter_InvalidChannelId",o.str(),
		    (const char *)"PseudoCounter::get_ch_from_id");
}


long PseudoCounter::get_ch_idx_from_id(long id)
{
	unsigned long ch_nb = channel_list.size();
	for(unsigned long ul = 0; ul < ch_nb; ul++)
	{	
		if(ch_mov[ul].id == id)
			return ul;
	}
	
	TangoSys_OMemStream o;
	o << "The pseudo counter does not contain the channel with id "<< id << ends;
	Tango::Except::throw_exception(
			(const char *)"PseudoCounter_InvalidChannelId",o.str(),
		    (const char *)"PseudoCounter::get_ch_from_id");
}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::pool_elem_changed
 *
 *	description: This method is called when the src object has changed
 *               and an event is generated 
 *
 * arg(s) : - evt [in]: The event that has occured
 *          - forward_evt [out]: the new internal event data to be sent
 *                               to all listeners
 */
//+------------------------------------------------------------------

void PseudoCounter::pool_elem_changed(Pool_ns::PoolElemEventList &evt_lst,
                                    Pool_ns::PoolElementEvent &forward_evt)
{
//
// State change from a channel
//
	Pool_ns::PoolElementEvent *evt = evt_lst.back(); 
	
	forward_evt.priority = evt->priority;
	
	switch(evt->type)
	{
		case Pool_ns::StateChange:
		{
			Tango::DevState old_state = get_state();
	
			long idx = get_ch_idx_from_id(evt->src->id);
			
			update_state_from_channels(idx, evt->new_state);
			
			Tango::DevState new_state = get_state();
			
			if(old_state != new_state)
			{
				Tango::AutoTangoMonitor synch(this);
				Tango::MultiAttribute *dev_attrs = get_device_attr();
				Tango::Attribute &state_att = dev_attrs->get_attr_by_name("State");
				state_att.fire_change_event();
			}
			
			forward_evt.type = Pool_ns::StateChange;
			forward_evt.old_state = old_state;
			forward_evt.new_state = new_state;
		}
		break;

//
//  value change event from a Counter/timer
//
		case Pool_ns::CTValueChange:
		case Pool_ns::ZeroDValueChange:
		case Pool_ns::PseudoCoValueChange:
		{
			Tango::DevState pc_state = get_state();
			
			long idx = get_ch_idx_from_id(evt->src->id);
			
			ch_values[idx] = evt->new_value;
			
			forward_evt.type = Pool_ns::PseudoCoValueChange;
			forward_evt.old_value = value; 

			calc();
			
			Tango::MultiAttribute *attr_list = get_device_attr();
			Tango::Attribute &attr = attr_list->get_attr_by_name ("Value");
			
			// Make sure the event is sent to all clients 
			if(true == evt->priority)
				attr.set_change_event(true,false);
			
			{			
				// get the tango synchronization monitor
				Tango::AutoTangoMonitor synch(this);
				
				// set the attribute value
				attr.set_value (attr_Value_read);
				
				if (pc_state == Tango::MOVING)
					attr.set_quality(Tango::ATTR_CHANGING);
				else if (pc_state == Tango::ALARM)
	  				attr.set_quality(Tango::ATTR_ALARM);
	  				
				// push the event
				attr.fire_change_event();			
			}
			
			if(true == evt->priority)
				attr.set_change_event(true,true);					
			
			forward_evt.priority = evt->priority;
			forward_evt.new_value = value; 
			forward_evt.dim = 1;
		}
		break;	
		
		default: 
		{
			assert(false);
		}
		break;
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void PseudoCounter::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Channel_id"));
	dev_prop.push_back(Tango::DbDatum("Channel_list"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	PseudoCounterClass	*ds_class =
		(static_cast<PseudoCounterClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize Channel_id from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  channel_id;
	//	Try to initialize Channel_id from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  channel_id;
	//	And try to extract Channel_id value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  channel_id;

	//	Try to initialize Channel_list from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  channel_list;
	//	Try to initialize Channel_list from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  channel_list;
	//	And try to extract Channel_list value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  channel_list;



	//	End of Automatic code generation
	//------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void PseudoCounter::always_executed_hook()
{
	if (should_be_in_fault())
	{
		set_state(Tango::FAULT);
	}
}
//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void PseudoCounter::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "PseudoCounter::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::read_ChannelList
// 
// description : 	Extract real attribute values for ChannelList acquisition result.
//
//-----------------------------------------------------------------------------
void PseudoCounter::read_ChannelList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "PseudoCounter::read_ChannelList(Tango::Attribute &attr) entering... "<< endl;
	
	vector<string>::iterator ite;
	long l = 0;
	for (ite = channel_list.begin();ite != channel_list.end();++ite)
	{
		attr_ChannelList_read[l++] = const_cast<char *>(ite->c_str());
	}

	attr.set_value(attr_ChannelList_read, channel_list.size());
}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status descrition
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString PseudoCounter::dev_status()
{
	Tango::ConstDevString	argout = DeviceImpl::dev_status();
	DEBUG_STREAM << "PseudoCounter::dev_status(): entering... !" << endl;

	//	Add your own code to control device here
	return argout;
}

//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::read_Value
// 
// description : 	Extract real attribute values for Value acquisition result.
//
//-----------------------------------------------------------------------------
void PseudoCounter::read_Value(Tango::Attribute &attr)
{
	DEBUG_STREAM << "PseudoCounter::read_Value(Tango::Attribute &attr) entering... "<< endl;
	
//
// Read values from channels
//
	unsigned long ch_nb = channel_list.size();
	double tmp_v;
	for(unsigned long ul = 0; ul < ch_nb; ul++)
	{	
		Tango::DeviceAttribute val_attr = 
			ch_mov[ul].proxy->read_attribute(ch_mov[ul].type == ZEROD ? "CumulatedValue" : "Value");
		val_attr >> tmp_v; 
		ch_values[ul] = tmp_v;
	}

	calc();
	
	attr.set_value(attr_Value_read);
}

//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::calc
// 
// description : 	Extract real attribute values for Value acquisition result.
//
//-----------------------------------------------------------------------------
double PseudoCounter::calc()
{
	Pool_ns::PseudoCoCtrlFiCa *pc_fica = get_pc_fica_ptr();
	
///
/// Pass the counter values the Python Pseudo Controller 
/// to get the pseudo counter value.
///
	Pool_ns::AutoPoolLock lo(pc_fica->get_mon());
	value = get_pc_ctrl()->Calc(ch_values);
	return value;
}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::start
 *
 *	description:	method to execute "Start"
 *	Start counting
 *
 *
 */
//+------------------------------------------------------------------
void PseudoCounter::start()
{
	DEBUG_STREAM << "PseudoCounter::start(): entering... !" << endl;

	//	Add your own code to control device here
	TangoSys_OMemStream o;
	o << "Start operation not implemented yet!";
	o << "\nPlease wait for a newer version";

	Tango::Except::throw_exception(
			(const char *)"PseudoCounter_MethodNotImplemented",o.str(),
		    (const char *)"Pool::start");

}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::abort
 *
 *	description:	method to execute "Abort"
 *	Stop counting
 *
 *
 */
//+------------------------------------------------------------------
void PseudoCounter::abort()
{
	DEBUG_STREAM << "PseudoCounter::abort(): entering... !" << endl;

	//	Add your own code to control device here
	base_abort(true);
}

//+------------------------------------------------------------------
/**
 *	method:	PseudoCounter::abort
 *
 *	description:	method to execute "Abort"
 *	Stop counting
 *
 *
 */
//+------------------------------------------------------------------
void PseudoCounter::base_abort(bool send_evt)
{
	DEBUG_STREAM << "PseudoCounter::abort(): entering... !" << endl;

	//	Add your own code to control device here
	TangoSys_OMemStream o;
	o << "Abort operation not implemented yet!";
	o << "\nPlease wait for a newer version";

	Tango::Except::throw_exception(
			(const char *)"PseudoCounter_MethodNotImplemented",o.str(),
		    (const char *)"Pool::abort");
}

PseudoCounterController *PseudoCounter::get_pc_ctrl() 
{
	return static_cast<PseudoCounterController *>(my_ctrl); 
}

Pool_ns::PseudoCoCtrlFiCa *PseudoCounter::get_pc_fica_ptr()
{
	return static_cast<Pool_ns::PseudoCoCtrlFiCa*>(fica_ptr); 
}


//+----------------------------------------------------------------------------
//
// method : 		PseudoCounter::get_pool_obj
// 
// description : 	gets Pool pseudo counter object for this pseudo counter
//                  Warning: the following method should only be executed
//                  when the running thread has a lock on the Pool
//
// \return the pool pseudo counter
//-----------------------------------------------------------------------------

Pool_ns::PoolElement &PseudoCounter::get_pool_obj()
{ 
	return pool_dev->get_pseudo_counter_from_id(channel_id); 
}

}	//	namespace
