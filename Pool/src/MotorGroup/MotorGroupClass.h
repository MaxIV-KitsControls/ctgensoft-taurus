//=============================================================================
//
// file :         MotorGroupClass.h
//
// description :  Include for the MotorGroupClass root class.
//                This class is represents the singleton class for
//                the MotorGroup device class.
//                It contains all properties and methods which the 
//                MotorGroup requires only once e.g. the commands.
//			
// project :      TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
// Revision 1.6  2007/04/30 14:51:20  tcoutinho
// - make possible to Add/Remove elements on motorgroup that are part of other motor group(s)
//
// Revision 1.5  2007/04/23 15:18:59  tcoutinho
// - first changes according to Sardana metting 26-03-2007: identical motor groups can be created, Add/Remove element from a MG, etc
//
// Revision 1.4  2006/11/20 14:35:17  etaurel
// - Add ghost group and event on group position
//
// Revision 1.3  2006/10/20 15:42:40  etaurel
// - First release with GetControllerInfo command supported and with
// controller properties
//
// Revision 1.2  2006/07/07 12:40:18  etaurel
// - Commit after implementing the group multi motor read
//
// Revision 1.1  2006/03/29 07:09:59  etaurel
// - Added motor group features
//
// copyleft :     CELLS/ALBA
//				  Edifici Ciències Nord. Mòdul C-3 central.
//  			  Campus Universitari de Bellaterra. Universitat Autònoma de Barcelona
//  			  08193 Bellaterra, Barcelona
//  			  Spain
//
//=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================

#ifndef _MOTORGROUPCLASS_H
#define _MOTORGROUPCLASS_H

#include <tango.h>
#include <MotorGroup.h>


namespace MotorGroup_ns
{
//=====================================
//	Define classes for attributes
//=====================================
/**
 * The class for the Elements attribute
 */
class ElementsAttrib: public Tango::SpectrumAttr
{
public:
	ElementsAttrib():SpectrumAttr("Elements", Tango::DEV_STRING, Tango::READ, 1024) {};
	~ElementsAttrib() {};
	
	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
	{(static_cast<MotorGroup *>(dev))->read_Elements(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
	{return (static_cast<MotorGroup *>(dev))->is_Elements_allowed(ty);}
};

/**
 * The class for the PseudoMotors attribute
 */
class PseudoMotorsAttrib: public Tango::SpectrumAttr
{
public:
	PseudoMotorsAttrib():SpectrumAttr("PseudoMotors", Tango::DEV_STRING, Tango::READ, 1024) {};
	~PseudoMotorsAttrib() {};
	
	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
	{(static_cast<MotorGroup *>(dev))->read_PseudoMotors(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
	{return (static_cast<MotorGroup *>(dev))->is_PseudoMotors_allowed(ty);}
};

/**
 * The class for the MotorGroups attribute
 */
class MotorGroupsAttrib: public Tango::SpectrumAttr
{
public:
	MotorGroupsAttrib():SpectrumAttr("MotorGroups", Tango::DEV_STRING, Tango::READ, 1024) {};
	~MotorGroupsAttrib() {};
	
	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
	{(static_cast<MotorGroup *>(dev))->read_MotorGroups(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
	{return (static_cast<MotorGroup *>(dev))->is_MotorGroups_allowed(ty);}
};

/**
 * The class for the Motors attribute
 */
class MotorsAttrib: public Tango::SpectrumAttr
{
public:
	MotorsAttrib():SpectrumAttr("Motors", Tango::DEV_STRING, Tango::READ, 1024) {};
	~MotorsAttrib() {};
	
	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
	{(static_cast<MotorGroup *>(dev))->read_Motors(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
	{return (static_cast<MotorGroup *>(dev))->is_Motors_allowed(ty);}
};

/**
 * The class for the Position attribute
 */
class PositionAttrib: public Tango::SpectrumAttr
{
public:
	PositionAttrib():SpectrumAttr("Position", Tango::DEV_DOUBLE, Tango::READ_WRITE, 256) {};
	~PositionAttrib() {};
	
	virtual void read(Tango::DeviceImpl *dev,Tango::Attribute &att)
	{(static_cast<MotorGroup *>(dev))->read_Position(att);}
	virtual void write(Tango::DeviceImpl *dev,Tango::WAttribute &att)
	{(static_cast<MotorGroup *>(dev))->write_Position(att);}
	virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty)
	{return (static_cast<MotorGroup *>(dev))->is_Position_allowed(ty);}
};

//=========================================
//	Define classes for commands
//=========================================
/**
 * The class for the RemoveElement command
 */
class RemoveElementCmd : public Tango::Command
{
public:
	RemoveElementCmd(const char   *name,
	               Tango::CmdArgType in,
				   Tango::CmdArgType out,
				   const char        *in_desc,
				   const char        *out_desc,
				   Tango::DispLevel  level)
	:Command(name,in,out,in_desc,out_desc, level)	{};

	RemoveElementCmd(const char   *name,
	               Tango::CmdArgType in,
				   Tango::CmdArgType out)
	:Command(name,in,out)	{};
	~RemoveElementCmd() {};
	
	virtual CORBA::Any *execute (Tango::DeviceImpl *dev, const CORBA::Any &any);
	virtual bool is_allowed (Tango::DeviceImpl *dev, const CORBA::Any &any)
	{return (static_cast<MotorGroup *>(dev))->is_RemoveElement_allowed(any);}
};


/**
 * The class for the AddElement command
 */
class AddElementCmd : public Tango::Command
{
public:
	AddElementCmd(const char   *name,
	               Tango::CmdArgType in,
				   Tango::CmdArgType out,
				   const char        *in_desc,
				   const char        *out_desc,
				   Tango::DispLevel  level)
	:Command(name,in,out,in_desc,out_desc, level)	{};

	AddElementCmd(const char   *name,
	               Tango::CmdArgType in,
				   Tango::CmdArgType out)
	:Command(name,in,out)	{};
	~AddElementCmd() {};
	
	virtual CORBA::Any *execute (Tango::DeviceImpl *dev, const CORBA::Any &any);
	virtual bool is_allowed (Tango::DeviceImpl *dev, const CORBA::Any &any)
	{return (static_cast<MotorGroup *>(dev))->is_AddElement_allowed(any);}
};


/**
 * The class for the Abort command
 */
class AbortClass : public Tango::Command
{
public:
	AbortClass(const char   *name,
	               Tango::CmdArgType in,
				   Tango::CmdArgType out,
				   const char        *in_desc,
				   const char        *out_desc,
				   Tango::DispLevel  level)
	:Command(name,in,out,in_desc,out_desc, level)	{};

	AbortClass(const char   *name,
	               Tango::CmdArgType in,
				   Tango::CmdArgType out)
	:Command(name,in,out)	{};
	~AbortClass() {};
	
	virtual CORBA::Any *execute (Tango::DeviceImpl *dev, const CORBA::Any &any);
	virtual bool is_allowed (Tango::DeviceImpl *dev, const CORBA::Any &any)
	{return (static_cast<MotorGroup *>(dev))->is_Abort_allowed(any);}
};



/**
 * The MotorGroupClass singleton definition
 */

class MotorGroupClass : public Tango::DeviceClass
{
public:
//	properties member data
/**
 *	Number of mS to sleep before the last read during a motor movment
 */
	Tango::DevLong	sleep_bef_last_read;

//	add your own data members here
//------------------------------------

	bool			first_call_to_device_factory;
	int				polling_th_id;
	
protected:
	void create_ghost_group();
	
public:
	Tango::DbData	cl_prop;
	Tango::DbData	cl_def_prop;
	Tango::DbData	dev_def_prop;

//	Method prototypes
	static MotorGroupClass *init(const char *);
	static MotorGroupClass *instance();
	~MotorGroupClass();
	Tango::DbDatum	get_class_property(string &);
	Tango::DbDatum	get_default_device_property(string &);
	Tango::DbDatum	get_default_class_property(string &);
	
protected:
	MotorGroupClass(string &);
	static MotorGroupClass *_instance;
	void command_factory();
	void get_class_property();
	void attribute_factory(vector<Tango::Attr *> &);
	void write_class_property();
	void set_default_property();

private:
	void device_factory(const Tango::DevVarStringArray *);
};

/**
 * Motor group dependencies on other motor groups.
 * 

 */
typedef struct MotorGroupDeps
{
	string alias;
	string name;
	vector<string> mg_direct_deps;
	vector<struct MotorGroupDeps *> mg_deps;
	
	bool operator<(MotorGroupDeps &mgd2)
	{
		bool res = true;
		if(find(mg_direct_deps.begin(),mg_direct_deps.end(),mgd2.alias) == mg_direct_deps.end())
		{
			vector<struct MotorGroupDeps *>::iterator ite = mg_deps.begin();
			for(;ite != mg_deps.end(); ite++)
				if(mgd2 < (**ite))
					return false;
		}
		else
		{
			return false;	
		}
		return true;
	}
	
	bool operator==(MotorGroupDeps &mgd2)
	{
		return alias == mgd2.alias;	
	}
};

}	//	namespace MotorGroup_ns

#endif // _MOTORGROUPCLASS_H
